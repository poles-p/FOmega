%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                            %%
%%                                              Wrocław, styczeń 2011 r.      %%
%%                                                                            %%
%%                                                                            %%
%%                                                                            %%
%%                                SYSTEMY TYPÓW - PROJEKT                     %%
%%                                                                            %%
%%                                   Piotr Polesiuk                           %%
%%                                Małgorzata Jurkiewicz                       %%
%%                                                                            %%
%%                                                                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[11pt,leqno]{article}

\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}


\usepackage{a4wide}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[pdftex]{graphicx}
\usepackage{caption}
\usepackage{bm}
\usepackage{amsthm}

 
%%%%%%%%%%%%%%%%%%
% Kropka po numerze paragrafu, podparagrafu itp. 

\makeatletter
 \renewcommand\@seccntformat[1]{\csname the#1\endcsname.\quad}
 \renewcommand\numberline[1]{#1.\hskip0.7em}
\makeatother

%%%%%%%%%%%%%%%%%%
% Kropka po numerze tablicy, rysunku i ustawienie czcionki dla etykiety. 

\captionsetup{labelfont=sc,labelsep=period}

%%%%%%%%%%%%%%%%%%
% Inna numeracja wzorów.

\renewcommand{\theequation}{\arabic{section}.\arabic{equation}}

%%%%%%%%%%%%%%%%%%

\title{{\textbf{System typów $F_{\omega}$}}\\[1ex]
       {\Large Systemy Typów 2010/11}\\[-1ex]
       {\large Prowadzący: dr Dariusz Biernacki}}
\author{Piotr Polesiuk \\ \texttt{bassists@o2.pl} 
   \and Małgorzata Jurkiewicz \\ \texttt{gosia.jurkiewicz@gmail.com}} 

\date{Wrocław, dnia \today\ r.}

\begin{document}
\thispagestyle{empty}
\maketitle

\pagebreak

\theoremstyle{plain}
\newtheorem{twierdzenie}{Twierdzenie}
\newtheorem{lemat}{Lemat}
\newtheorem{fakt}{Fakt}

\theoremstyle{definition}
\newtheorem{definicja}{Definicja}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Wstęp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}


No to na razie taki bałagan



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{System $F_{\omega}$}                                 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}

W rozdziale tym chcielibyśmy się skupić na systemie $F_{\omega}$ okrojonym do niezbędnego minimum.
Przedstawimy, jak wyglądają termy, typy i wartości tego języka, a także pokażemy, jak przebiega typowanie,
znajdowanie rodzaju, ewaluacja czy sprawdzanie równości typów. Postaramy się pisać jasno i pokażemy parę przykładów, 
aby nieobyty w temacie Czytelnik nie zgubił się.  W rozdziale trzecim do tak zdefiniowanego systemu będziemy wprowadzać
rozszerzenia.

\subsection {Termy i typy w $F_\omega$}

System $F_{\omega}$ to rachunek będący rozszerzeniem $\lambda_{\omega}$ oraz systemu $F$.
Wszystkie trzy wywodzą się z rachunku lambda z typami prostymi. Termy oraz typy definiujemy w $\lambda_{\rightarrow}$ następująco: \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= &  & \textit{termy}  \\
   & $\mathtt{x}$ & \textit{zmienne}  \\
   & $\mathtt{\lambda x:T.t}$ & \textit{abstrakcja} \\
   & $\mathtt{t \hspace{0.2em} t}$ & \textit{aplikacja} \\
   & & \\
  $\mathtt{T}$ ::= &  & \textit{typy} \\
   & $\mathtt{X}$ & \textit{zmienna typowa} \\
   & $\mathtt{T \rightarrow T}$ & \textit{typ funkcji} \\
  \hline
\end{tabular} \\



\subsubsection{System $\lambda_{\omega}$} 

Główną cechą systemu $\lambda_{\omega}$ jest to, że oprócz termów zależnych od termów mamy typy zależne od typów, czyli możemy mówić o aplikacji i abstrakcji typowej, a tak powstałe 'typy' będziemy nazywać konstruktorami. By nam się nie pomyliło z abstrakcją na termach, zmienne konstruktorowe będziemy zaczynać dużą literą. Przykładowo $\mathtt{Tb=\lambda X.X \rightarrow Bool}$ i $\mathtt{\lambda X.X}$ są abstrakcjami konstruktowymi, ale $\mathtt{\lambda x.x}$ jest abstrakcją na termach. 
Do konstruktora $\mathtt{Tb}$ możemy zaaplikować $\mathtt{Bool}$ i dostaniemy $\mathtt{(\lambda X.X \rightarrow Bool)Bool}$ równoważne $\mathtt{Bool \rightarrow Bool}$. Jak widać, użyliśmy słowa \textit{równoważne}. W rachunku lambda z typami prostymi sposób konstrukcji typów gwarantował nam, że dwa typy $\mathtt{T_1}$ i $\mathtt{T_2}$ na pewno są różne (zakładając, że typy bazowe były sobie różne). W $\lambda_{\omega}$ jest inaczej -- konstruktory tego systemu możemy podzielić na klasy równoważności. Do klasy $\mathtt{Bool \rightarrow Bool}$ należą również $\mathtt{ (Tb^n) Bool }$ dla $n$ naturalnego, a $\mathtt{T^n}$ oznacza aplikację $n$ konstruktorów $\mathtt{T}$.
Zauważmy, że odpowiednikiem takiej relacji równoważności w $\lambda_{\rightarrow}$  jest $\beta$-równoważność. W~świecie typów nazwiemy taką relację $\equiv$\footnote{formalnie zdefiniujemy tą relację w rozdziale 2.2.3}. Każdy konstruktor typu jest silnie normalizowalny i zachodzi własność Churcha-Rossera. Przez \texttt{nf(T)} oznaczamy postać normalną konstruktora rodzaju \texttt{T}.
Dodatkowo wprowadzimy następującą regułę:
$\mathtt{\frac{\Gamma \vdash t:S \hspace{1em} S\equiv T  }{\Gamma \vdash t:T}}$
mówiącą, że jeżeli \texttt{S} jest konstruktorem termu \texttt{t}, to dowolny konstruktor \texttt{S} równoważny z \texttt{T} również jest konstruktorem \texttt{t}.  

Niestety, w tak zdefiniowanym systemie powstaje jeden problem. Nie chcielibyśmy, aby $\mathtt{Bool \hspace{0.2em} Bool}$ było dozwolone, tak samo, jak w świecie termów nie chcieliśmy, by $\mathtt{true \hspace{0.2em} true}$ było dozwolone. W świecie termów, by rozwiązać ten problem, wprowadziliśmy typy na termach, w świecie typów wprowadzimy \textit{rodzaje} na konstruktorach. Piszemy, że $\mathtt{T::K}$, czyli konstruktor $\mathtt{T}$ jest rodzaju $\mathtt{K}$. Wprowadzimy też jeden rodzaj bazowy $\mathtt{\ast}$.

Wszystkie typy, jakie pojawiły się w $\lambda_{\rightarrow}$, są rodzaju $\mathtt{\ast}$. Np. $\mathtt{Bool :: \ast}$, $\mathtt{Nat \rightarrow Nat}$, $\mathtt{(Bool \rightarrow Nat) \rightarrow Nat} :: \ast$, itd. Rodzaj $\mathtt{\ast \Rightarrow \ast}$ będzie odpowiadał funkcjom z konstruktorów w konstruktory, np. $\mathtt{\lambda X.X \rightarrow Bool::\ast \Rightarrow \ast }$. $\mathtt{\ast \Rightarrow \ast \Rightarrow \ast}$ bierze konstruktor i zwraca funkcję konstruktorową, np. $\mathtt{\lambda X. \lambda Y. X \rightarrow Y::\ast \Rightarrow \ast \Rightarrow \ast}$, itd. 

Teraz możemy $\lambda_{\rightarrow}$ rozszerzyć o następujące konstrukcje: 
\begin{itemize}
    \item rodzaje \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{K}$ ::= &  & \textit{rodzaje}  \\
   & $\mathtt{\ast}$ & \textit{rodzaj wszystkich typów} \\
   & $\mathtt{K \Rightarrow K}$ & \textit{rodzaj funkcji typowej} \\
  \hline
\end{tabular}
    \item abstrakcję i aplikację typową na typach \\ \\
\begin{tabular}{| l c r |}
   \hline
   $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{\lambda X::K.T}$ & \textit{abstrakcja konstruktorowa} \\
   & $\mathtt{T\;T}$ & \textit{aplikacji konstruktorowa} \\
   \hline
\end{tabular}
\end{itemize} 

Powstaje pytanie, czy wszystkie konstruktory są typami? Otóż nie, typy to konstruktory rodzaju $\mathtt{\ast}$.

\subsubsection{System $F$}

System F jest systemem, w którym dodatkowo, oprócz termów zależnych od termów, mamy termy zależne od typów. Wprowadzimy trzeci już rodzaj abstrakcji i aplikacji, poprzedni był w świecie typów, ten będzie w świecie termów. Znana jest nam funkcja identycznościowa $\mathtt{\lambda x.x}$, w $\lambda_{\rightarrow}$ możemy ją napisać na wiele sposób: $\mathtt{\lambda x:Bool.x}$, $\mathtt{\lambda x:Nat.x}$, $\mathtt{\lambda x:Bool \rightarrow Nat.x}$. W systemie $F$ możemy wszystkie te funkcje zapisać jako: $\mathtt{\lambda X. \lambda x:X.x}$. Zauważmy, że ten \textit{term} przyjmuje jako pierwszy argument typ, następnie term tego typu i zwraca term. Przykładem użycia takiego termu mogą być: $(\mathtt{\lambda X. \lambda x:X.x)\;[Bool]\;true}$, co daje $\mathtt{true}$, albo $(\mathtt{\lambda X. \lambda x:X.x)\;[Nat]\;1}$, co daje $\mathtt{1}$. W ten sposób powstała nam \textit{uniwersalna} funkcja identycznościowa, której nadamy tzw. uniwersalny typ: $\mathtt{\lambda X. \lambda x:X.x \; : \; \forall X.X \rightarrow X}$. Dodatkowo, jako że dodaliśmy już do systemu rodzaje, napiszemy $\mathtt{\lambda X::\ast. \lambda x:X.x \; : \; \forall X::\ast.X \rightarrow X \; ::\ast}$. 

Czy moglibyśmy napisać $\mathtt{\lambda X::\ast \Rightarrow \ast. \lambda x:X.x \; : \; \forall X::\ast \Rightarrow \ast.X \rightarrow X \; ::\ast \Rightarrow \ast}\;$? Jak już mówiliśmy, tylko konstruktory rodzaju $\mathtt{\ast}$ są typami, więc powyższy term nie jest dobry.

Po tym krótkim wstępie możemy już zdefiniować odziedziczone z systemu $F$ własności takie, jak:  
\begin{itemize}
    \item abstrakcję i aplikację typową na termach \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy} \\
   & $\mathtt{\lambda X::K.t}$ & \textit{abstrakcja typowa} \\
   & $\mathtt{t[T]}$ & \textit{aplikacja typowa} \\
  \hline
\end{tabular}

    \item typ uniwersalny \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{\forall X::K.T}$ & \textit{typ uniwersalny} \\
  \hline
\end{tabular}

\end{itemize}


\subsection{Typowanie}

\subsubsection{Kontekst}

\emph{Kontekst typowania} opisany jest następującą składnią abstrakcyjną: \\

\begin{tabular}{ | l c r | }
	\hline
	$\mathtt{\Gamma}$ ::= & & \textit{kontekst}\\
	& $\mathtt{\emptyset}$ & \textit{pusty kontekst} \\
	& $\mathtt{\Gamma,x:T}$& \textit{wiązanie typu} \\ 
	& $\mathtt{\Gamma,X::K}$& \textit{wiązanie rodzaju} \\ 
	\hline
\end{tabular} \\
	
Konteksty typowania bedziemy często traktować jako skończone zbiory wiązań i będziemy
używać teoriomnogościowych symboli na nich. Np. przynależność do kontekstu formalnie
definiujemy jako:
\[
	\frac{}{B \in \Gamma,B}
	\qquad
	\frac{B \in \Gamma}{B \in \Gamma,B'}
\]
Definicje pozostałych operacji teoriomnogościowych są na tyle naturalne, że zostawiamy
je Czytelnikowi do uzupełnienia.


\subsubsection{Podstawienia}
Oprócz zwykłego podstawienia za zmienne, które pozostawiamy Czytelnikowi do uzupełnienia, powinniśmy zdefiniować podstawienie za zmienne konstruktorowe.

    \begin{itemize}
        \item $\mathtt{[Y \mapsto T]X = \begin{cases}  \texttt{T} & Y=X \\ \texttt{X} & \text{w.p.p} \end{cases}}$
        \item $\mathtt{[Y \mapsto T](X_1 \; X_2)  = [Y \mapsto T]X_1 [Y \mapsto T] X_2 }$
        \item $\mathtt{[Y \mapsto T](S_1 \rightarrow S_2) = [Y \mapsto T]S_1 \rightarrow [Y \mapsto T]S_2} $
        \item $\mathtt{[Y \mapsto T]\forall X.S}  = \begin{cases} \mathtt{\forall X.S} & Y=X \text{ lub } Y \notin FV(S) \\ \mathtt{\forall X.[Y \mapsto T]S} & X \notin FV(S)  \text{ i } Y \in FV(S) \end{cases}$
        \item $\mathtt{[Y := T]\lambda X.S }= \begin{cases} \mathtt{\lambda X.S} & Y=X \text{ lub } Y \notin FV(S)\\ \mathtt{\lambda X.[Y \mapsto T]S}  & X \notin FV(S)  \text{ i } Y \in FV(S) \end{cases}$
    \end{itemize}

\subsubsection{Relacja $\equiv$}

Jak wspomnieliśmy w rozdziale 2.1.1, definiujemy na typach relację równoważności. W poniższych wzorach $\mathtt{S,S_1,S_2,T,T_1,T_2}$ to typy, \texttt{K} to rodzaj. Następujące trzy reguły:
	\[\mathtt{
		\frac{}{T \equiv T}
                \qquad
                \frac{S \equiv T}{T \equiv S}}
                \qquad
                \frac{S \equiv U \;\; U \equiv T}{S \equiv T}
	\]
gwarantują nam równoważność relacji $\equiv$. Pozostałe reguły jak następuje:
	\[\mathtt{
		\frac{S_1 \equiv T_1 \;\; S_2 \equiv T_2}{S_1 \rightarrow S_2 \equiv T_1 \rightarrow T_2}
                \qquad
                \frac{S_1 \equiv T_1 \;\; S_2 \equiv T_2}{S_1\;S_2 \equiv T_1\;T_2}}
	\]
	\[\mathtt{
		\frac{S \equiv T}{\lambda X::K.S \equiv \lambda X::K.T}
                \qquad
                (\lambda X::K.S)T \equiv [X \mapsto T]S}
	\] 

definiują równoważność funkcji typowych, aplikacji i abstrakcji konstruktorowych oraz typów uniwersalnych.

\subsubsection{Reguły znajdowania rodzaju}

W systemie $F_\omega$ każdemu poprawnie zbudowanemu typowi przyporządkowujemy rodzaj.
Przyporządkowanie to określa relacja $(.\vdash.::.)$ zdefiniowana następująco.

Jeżeli zachodzi $\mathtt{\Gamma \vdash T :: K}$, to powiemy, że
\emph {typ $\mathtt{T}$ jest rodzaju $\mathtt{K}$ w~kontekście $\mathtt{\Gamma}$}, gdzie
relacja określenia rodzaju $(.\vdash.::.) \subseteq \Gamma \times T \times K$
jest najmniejszą relacją zamkniętą na reguły:
	\[ \mathtt{
		\frac{X::K \in \Gamma}{\Gamma \vdash X::K}
		\qquad
		\frac{\Gamma \vdash T_1 :: K_{1} \Rightarrow K_{2} \hspace{1em} \Gamma \vdash T_2 :: K_{1}}{\Gamma \vdash T_1 T_2 :: K_{2}}}
	\]
	\[ \mathtt{
		\frac{\Gamma \vdash X :: K_1 \hspace{1em} \Gamma \vdash T :: K_2}{\Gamma \vdash \lambda X::K_1. T :: K_{1} \Rightarrow K_{2}}
		\qquad
		\frac{\Gamma \vdash X :: K \hspace{1em} \Gamma \vdash T :: \ast}{\Gamma \vdash \forall X::K. T :: \ast}}
	\]
	\[\mathtt{
		\frac{\Gamma \vdash T_1 : \ast \hspace{1em} \Gamma \vdash T_2 : \ast}{\Gamma \vdash T_1 \rightarrow T_2 : \ast}}
	\]	


\subsubsection{Reguły typowania}

Jesteśmy już gotowi przedstawić reguły typowania zdefiniowanego wyżej systemu $F_\omega$.
Każdemu poprawnie zbudowanemu termowi przyporządkowujemy typ. Przyporządkowanie to określa relacja $(.\vdash.:.)$ zdefiniowana następująco.

	\[\mathtt{
		\frac{x:T \in \Gamma}{\Gamma \vdash x:T}
                \qquad
                \frac{\Gamma \vdash T_1::\ast \hspace{1.5em} \Gamma,x:T_1 \vdash t_2:T_2}{\Gamma \vdash \lambda x:T_1.t_2\;:\;T_1 \rightarrow T_2}}
	\]
	\[\mathtt{
		\frac{\Gamma \vdash t_1:T_1 \rightarrow T_2 \hspace{1.5em} \Gamma \vdash t_2:T_1}{ \Gamma \vdash t_1 \; t_2 : T_2}
                \qquad
                \frac{\Gamma \vdash t:S \hspace{1.5em} S \equiv T \hspace{1.5em} \Gamma \vdash T::\ast}{\Gamma \vdash t:T}}
	\]
	\[\mathtt{
		\frac{\Gamma,X::K \vdash t:T }{\Gamma \vdash \lambda X::K.t \;:\forall X::K.T}
                \qquad
                \frac{\Gamma \vdash t:\forall X::K.T \hspace{1.5em} \Gamma \vdash T'::K}{\Gamma \vdash t[T']\;:[X \mapsto T']T}}
	\]


\subsection{Ewaluacja}

Wartości w $F_\omega$ zdefiniujemy dokładnie jak w $\lambda_{\rightarrow}$. \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{v}$ ::= &  & \textit{wartości}  \\
   & $\mathtt{\lambda x:T.t}$ & \textit{wartość abstrakcji} \\
  \hline
\end{tabular} \\

Ewaluacja przebiega w sposób standardowy dla aplikacji i abstrakcji termów. Teraz, dla czytelności, przetoczymy te reguły ewaluacji ($\mathtt{t_1,t_1',t_2,t_2',t}$ to termy, \texttt{v} to wartość, \texttt{x:T} to zmienna \texttt{x} typu \texttt{T}):
	\[\mathtt{
		\frac{t_1 \longrightarrow t_1'}{t_1\;t_2 \longrightarrow t_1'\;t_2}
                \qquad
                \frac{t_2 \longrightarrow t_2'}{v_1\;t_2 \longrightarrow v_1\;t_2'}}
	\]
 	\[\mathtt{
		(\lambda x:T.t)v \longrightarrow [x \mapsto v]t}
	\]
Do tego dochodzą reguły dla nowych w języku abstrakcji typowych i aplikacji typowych.
	\[\mathtt{
		\frac{t \longrightarrow t'}{t[T] \longrightarrow t'[T]}}
	\]
 	\[\mathtt{
		(\lambda X::K.t)[T] \longrightarrow [X \mapsto T]t}
	\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rozszerzenia $F_\omega$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}

W rozdziale tym chcielibyśmy poruszyć, jak w systemie $F_\omega$ zdefiniować najprostsze
konstrukcje, takie jak wyrażenia arytmetyczne i logiczne, warianty, sekwencje wyrażeń, 
typy egzystencjalne, rekordy i inne. Pokażemy również, jak przebiega typowanie, ewaluacja i 
gdzieniegdzie dodamy reguły tworzenia rodzaju.

Chcielibysmy podkreślić, że następująca reguła typowania:

 	\[\mathtt{ \frac{\Gamma \vdash t:T \;\;\; S\equiv T \;\;\; \Gamma \vdash S::\ast}{\Gamma \vdash t:S}
		}
	\]
bardzo ułatwia definiowanie reguł typowania w $F_\omega$. W większości przypadków są one takie same lub
lekko zmodyfikowane, dlatego nie powinny nastręczać trudności.

\subsection{wyrażenia arytmetyczne i logiczne}

Wyreżania arytmetyczne i logiczne to część, bez której żaden język się nie obędzie. Oczywiście można je sobie zakodować w systemie $F_\omega$, ale normą są wbudowane w język wyrażenia. Termy, typy i wartości wyrażeń zdefiniujemy następująco: \\

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{true}$ & \textit{prawda}  \\
   & $\mathtt{false}$ & \textit{fałsz} \\
   & $\mathtt{zero}$ & \textit{zero} \\
   & $\mathtt{succ\;t}$ & \textit{następnik}  \\
   & $\mathtt{pred\;t}$ & \textit{poprzednik} \\
   & $\mathtt{iszero}$ & \textit{test na zero} \\
   & $\mathtt{if\;t\;then\;t\;else\;t}$ & \textit{warunek} \\
   & & \\
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy} \\
   & $\mathtt{Nat}$ & \textit{typ liczbowy} \\
   & $\mathtt{Bool}$ & \textit{typ boolowski} \\
   & & \\
  $\mathtt{v}$ ::= & $\dots$ & \textit{typy} \\
   & $\mathtt{true}$ & \textit{wartość prawdy} \\
   & $\mathtt{false}$ & \textit{wartość fałszu} \\
   & $\mathtt{nv}$ & \textit{wartość liczbowa} \\
   & & \\
  $\mathtt{nv}$ ::= & $\dots$ & \textit{wartość liczbowa} \\
   & $\mathtt{zero}$ & \textit{wartość zera} \\
   & $\mathtt{succ\;nv}$ & \textit{wartość następnika} \\
  \hline
\end{tabular} \\

Na pewno musimy dodać reguły tworzenia rodzaju dla \texttt{Nat} i \texttt{Bool}, którym nadamy rodzaj~$\mathtt{\ast}$:
 	\[\mathtt{ \frac{}{\Gamma \vdash Bool::\ast} \qquad \frac{}{\Gamma \vdash Nat::\ast}
		}
	\]

Typowanie wygląda dokładnie tak samo jak w rachunku lambda z typami prostymi. Możemy sobie pozwolić na takie reguły dzięki regule XXX.
Przykładowo, nie tylko termy typu \texttt{Nat} mogą się dobrze otypować, gdy zaaplikujemy je do \texttt{succ}. Dla $\mathtt{t:(\lambda X.X)Nat}$
otrzymamy:

 	\[\mathtt{ \frac{\frac{\Gamma \vdash t:(\lambda X.X)Nat\hspace{2em}\Gamma \vdash (\lambda X.X)Nat \equiv Nat \hspace{2em}\Gamma \vdash (\lambda X.X)Nat::\ast}{\Gamma \vdash t:Nat}}{\Gamma \vdash succ\;t:Nat} 
		}
	\]
Nie musimy również pisać reguł typu:~\[\mathtt{\frac{\Gamma \vdash t_1:Bool \;\;\; \Gamma \vdash t_2:T \;\;\; \Gamma \vdash t_3:T\;\;\; \Gamma \vdash T::\ast}{\Gamma \vdash if\;t_1\;then\;t_2\;else\;t_3:T} 
		}
	\]
ponieważ posiadanie typu przez term $\mathtt{t_2}$ gwarantuje nam, że ten typ będzie rodzaju $\mathtt{\ast}$.
Stąd, reguły typowania wyrażeń arytmetycznych i logicznych wyglądają następująco w $F_\omega$:~\[\mathtt{ \frac{}{\Gamma \vdash true:Bool} \qquad \frac{}{\Gamma \vdash false:Bool} \quad \frac{\Gamma \vdash t:Nat}{\Gamma \vdash iszero\;t:Bool}
		}
	\]
 	\[\mathtt{\frac{\Gamma \vdash t_1:Bool \;\;\; \Gamma \vdash t_2:T \;\;\; \Gamma \vdash t_3:T}{\Gamma \vdash if\;t_1\;then\;t_2\;else\;t_3:T} 
		}
	\]
 	\[\mathtt{ \frac{}{\Gamma \vdash zero:Nat} \qquad \frac{\Gamma \vdash t:Nat}{\Gamma \vdash succ\;t:Nat} \qquad \frac{\Gamma \vdash t:Nat}{\Gamma \vdash pred\;t:Nat} 
		}
	\]
Zdefiniowanie reguł ewaluacji pozostawiamy Czytelnikowi.

\subsection{Unit i sekwencje}

W rachunku lambda z typami prostymi dodaliśmy do składnię języka rozszerzaliśmy o konstrukcje takie, jak: 

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{unit}$ & \textit{term unit} \\
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{Unit}$ & \textit{typ unit} \\
  $\mathtt{v}$ ::= & $\dots$ & \textit{wartości}  \\
   & $\mathtt{unit}$ & \textit{wartość unit} \\
  \hline
\end{tabular} \\

natomiast typowanie przebiegało następująco:~\[\mathtt{ \frac{}{\Gamma \vdash unit:Unit}
		}
	\]
a sekwencje definiowaliśmy jako:~\[\mathtt{ t_1;t_2 \;\overset{def}{=}\; (\lambda x:Unit.t_2)t_1 \hspace{3em} \text{gdzie x $\notin$ FV($t_2$)}
		}
	\]
Aby pozostać przy wbudowanym unit w język wystarczy dodać regułę znajdowania rodzaju dla typu \texttt{Unit}:~\[\mathtt{ \frac{}{\Gamma \vdash Unit::\ast}
		}
	\]

W rachunku $F_\omega$ pojawia się możliwość zakodowania \texttt{unit} i \texttt{Unit}. Robimy to w taki sposób:
$\mathtt{unit \;\overset{def}{=}\;= \lambda X::\ast.\lambda x:X.x}$ \\
$\mathtt{Unit \;\overset{def}{=}\; \forall X::\ast.X \rightarrow X}$ \\


\subsection{Anotacje typowe}

Anotacje typowe są przydatną konstrukcją używaną na przykład przy typach egzystencjalnych.\\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\cdots$ & \textit{termy}  \\
   & $\mathtt{t\;as\;T}$ &\textit{anotacja typowa} \\
  \hline
\end{tabular} \\

Ewaluacja i typowanie nie zmieniają się.

\subsection{Definicje lokalne}

 	\[\mathtt{let\;x=t_1\;in\;t_2 \;\overset{def}{=}\;(\lambda x:T.t_2)t_1 \hspace{3em}\text{gdzie}\; t_1:T 
		}
	\]

\subsection{Rekordy}

Składnię rekordów zdefiniujemy następująco:\\

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{\{l_i=t_i^{\;\;\;i \in 1..n}\}}$ & \textit{rekord} \\
   & $\mathtt{t.l}$ & \textit{projekcja} \\ 
   & & \\
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{\{l_i:T_i^{\;\;\;i \in 1..n}\}}$ & \textit{typ rekordu} \\
   & & \\
  $\mathtt{v}$ ::= & $\dots$ & \textit{wartości}  \\
   & $\mathtt{\{l_i=v_i^{\;\;\;i \in 1..n}\}}$ & \textit{wartość rekordu} \\
  \hline
\end{tabular} \\

Do relacji tworzenia rodzaju dodamy regułę nadającą rodzaj typowi $\mathtt{\{l_i:T_i^{\;\;\;i \in 1..n}\}}$:~\[\mathtt{
             \frac{\Gamma \vdash T_1::\ast \;\dots\;\Gamma \vdash T_n::\ast}{\Gamma \vdash \{l_i:T_i^{\;\;\;i \in 1..n}\}::\ast}
		}
	\]
oraz wprowadzimy niewielkie zmiany w regułach typowania:~\[\mathtt{
             \frac{\Gamma \vdash t_1:T_1 \;\dots\;\Gamma \vdash t_n:T_n \hspace{2em} \Gamma \vdash \{l_i:T_i^{\;\;\;i \in 1..n}\}::\ast}{\Gamma \vdash \{l_i=t_i^{\;\;\;i \in 1..n}\}:\{l_i:T_i^{\;\;\;i \in 1..n}\}}
            }
	\]
 	\[\mathtt{
           \frac{\Gamma \vdash t : \{l_i:T_i^{\;\;\;i \in 1..n}\}}{\Gamma \vdash t.i : T_i} 
            }
	\]
a ewaluację pozostawimy bez zmian: \\
 	\[\mathtt{
                \{l_i=v_i^{\;\;\;i \in 1..n}\}.i \longrightarrow v_i
                \qquad
                \frac{e \longrightarrow e'}{e.i \longrightarrow e'.i}
		}
	\]
\small{
 	\[\mathtt{
                \frac{t_i \longrightarrow t_i'}{\{l_1=v_1, \dots, l_{i-1}=v_{i-1}, l_i=t_i, \dots, l_n=t_n\} \longrightarrow \{l_1=v_1, \dots, l_{i-1}=v_{i-1}, l_i=t_i', \dots, l_n=t_n\}}
		}
	\]
}
\subsection{Warianty}

Składnię wariantów zdefiniujemy następująco:\\

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{<l=t>\;as\;T}$ & \textit{tagowanie} \\
   & $\mathtt{case\;t\;of\;<l_i=x_i>\Rightarrow t_i^{\;\;\;i \in 1..n}}$ & \textit{case}\\
   & & \\
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{<l_i:T_i^{\;\;\;i \in 1..n}>}$ & \textit{typ wariantu}\\
  \hline
\end{tabular} \\

Podobnie jak przy rekordach, typ wariantu dostanie rodzaj $\mathtt{\ast}$:
 	\[\mathtt{
             \frac{\Gamma \vdash T_1::\ast \;\dots\;\Gamma \vdash T_n::\ast}{\Gamma \vdash <l_i:T_i^{\;\;\;i \in 1..n}>::\ast}
		}
	\]
a w regułąch typowania wprowadzimy małe zmiany:
 	\[\mathtt{ \frac{\Gamma \vdash t_0:<l_i:T_i^{\;\;\;i \in 1..n}> \hspace{2em} \Gamma,x_1:T_1 \vdash t_1:T \;\dots\; \Gamma,x_n:T_n \vdash t_n:T}{\Gamma \vdash case\;t_0\;of\;<l_i=x_i>\Rightarrow t_i^{\;\;\;i \in 1..n}\; : T}
		}
	\]
 	\[\mathtt{ \frac{\Gamma \vdash t_j : T_j \hspace{2em} \Gamma \vdash <l_i:T_i^{\;\;\;i \in 1..n}>::\ast}{\Gamma \vdash <l_j=t_j> as <l_i:T_i^{\;\;\;i \in 1..n}> \;: <l_i:\;T_i^{\;\;\;i \in 1..n}>}
		}
	\]
natomiast ewaluacja pozostanie bez zmian:
 	\[\mathtt{ case\;(<l_j=t_j>\;as\;T)\;of\;<l_i=x_i>\Rightarrow t_i^{\;\;\;i \in 1..n} \longrightarrow [x_j \mapsto v_j]t_j
		}
	\]
 	\[\mathtt{ \frac{t \longrightarrow t'}{case\;t\;of\;<l_i=x_i>\Rightarrow t_i^{\;\;\;i \in 1..n} \longrightarrow case\;t'\;of\;<l_i=x_i>\Rightarrow t_i^{\;\;\;i \in 1..n} }
		}
	\]
 	\[\mathtt{ \frac{t_j \longrightarrow t_j'}{<l_j=t_j>\;as\;T \longrightarrow <l_j=t_j'>\;as\;T }
		}
	\]

\subsection{Punkt stały}

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{fix \;t.v}$ & \textit{punkt stały}\\
  \hline
\end{tabular} \\

Typowanie \\
 	\[\mathtt{\frac{\Gamma, f:T \vdash v:S \hspace{2em} \Gamma \vdash T::\ast\hspace{2em} \Gamma \vdash S::\ast \hspace{2em} S\equiv T}{\Gamma \vdash fix\;f.v:T}}
	\]
Ewaluacja \\
 	\[\mathtt{ fix\;f.v \longrightarrow [f \mapsto fix\;f.v]v
		}
	\]

\subsection{Listy}

Jako przykład wbudowanych typów danych wybraliśmy listy. Podobne rekursywne struktury, jak na przykład drzewa, możemy dodać do języka w analogiczny sposób, jednak rekurencyjne typy danych odwiodą nas od tej konieczności. \\
  
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{nil[T]}$ & \textit{lista pusta}  \\
   & $\mathtt{cons[T]\;t\;t}$ & \textit{konstruktor listy} \\
   & $\mathtt{isnil[T]\;t}$ & \textit{test na pustość listy} \\
   & $\mathtt{head[T]\;t\;t}$ & \textit{głowa listy} \\
   & $\mathtt{tail[T]\;t}$ & \textit{ogon listy} \\
   & & \\
  $\mathtt{T}$ ::= &  & \textit{typy} \\
   & $\mathtt{List\;T}$ & \textit{typ listy} \\
   & & \\
  $\mathtt{v}$ ::= &  & \textit{typy} \\
   & $\mathtt{nil\;[T]}$ & \textit{wartość pustej listy} \\
   & $\mathtt{cons\;[T]\;v\;v}$ & \textit{wartość listy niepustej} \\
  \hline
\end{tabular} \\

Tworzenie rodzaju:
 	\[\mathtt{ \frac{\Gamma \vdash T::\ast}{\Gamma \vdash List\;T::\ast}
		}
	\]
Typowanie:
 	\[\mathtt{ \frac{\Gamma \vdash List\;T :: \ast}{\Gamma \vdash nil[T] : List\;T } \qquad \frac{\Gamma \vdash t_1:T \;\;\;\Gamma \vdash t_2:List\;T}{\Gamma \vdash List[T]\;t_1\;t_2:List\;T}
		}
	\]
 	\[\mathtt{ \frac{\Gamma \vdash t:List\;T }{\Gamma \vdash head[T]\;t : T } \qquad \frac{\Gamma \vdash t:List\;T }{\Gamma \vdash tail[T]\;t : List\;T }
		}
	\]
Ewaluacja:
 	\[\mathtt{ aaa
		}
	\]
\subsection{Typy egzystencjalne}

System $F_\omega$ jest już w stanie zakodować typy egzystencjalne, choć wbudowane typy egzystencjalne niczemu nie szkodzą. Pokażemy oba podejścia do tego problemu, zaczynając od przedstawienia składni: \\

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\cdots$ & \textit{termy}  \\
   & $\mathtt{\{^*T::K,t\}\;as\;T}$ & \textit{pakowanie} \\
   & $\mathtt{let\;\{X,x\}=t\;in\;t}$ & \textit{odpakowanie} \\
   & & \\
  $\mathtt{T}$ ::= & $\cdots$ & \textit{typy}  \\
   & $\mathtt{\{\exists X::K,T\}}$ & \textit{typ egzystencjalny} \\
   & & \\
  $\mathtt{v}$ ::= & $\cdots$ & \textit{wartości}  \\
   & $\mathtt{\{^*T,v\}\;as\;T}$ & \textit{pakowanie} \\
  \hline
\end{tabular} \\

W systemie $F_\omega$ powyższe elementy języka możemy zdefiniować następująco: \\
$\mathtt{\{\exists X::K,T\}\;\overset{def}{=}\;\forall Y::\ast.(\forall X::K.T \rightarrow Y) \rightarrow Y}$ \\
$\mathtt{\{^*U::K,t\}\;as\; \{\exists X::K,T\}\; \overset{def}{=} \;let\;x=t\;in\;\lambda Y::\ast.(\lambda f:\forall X::K.T \rightarrow Y) .f\;[U]\;x}$ \\
$\mathtt{let\;\{X::K,x\}=t\;in\;t'\;\overset{def}{=}\;t[T'](\lambda X::K.\lambda x:T.t')\hspace{3em} \text{gdzie $\mathtt{t':T'}$} }$ \\ \\

Zauważmy, że dopiero obecność rodzajów pozwoliła nam na tego rodzaju sztuczki. W~systemie $F$ nie umiemy tak zrobić.

Na pierwszy rzut oka termy te są niezrozumiałe. Ależ jak bardzo można się mylić -- są miłe i przyjemne dla swych wielbicieli. Pokażemy, że zachodzą podstawowe własności pakowania i odpakowania. \\
Rozważmy term $\mathtt{ \{^*U::K,t\}\;as\; \{\exists X::K,T\}}$. \\ 
$ \mathtt{ \{^*U::K,t\}\;as\; \{\exists X::K,T\} }$ \\ 
$ \mathtt{ = let\;x=t\;in\;\lambda Y::\ast.\lambda f:(\forall X::K.T \rightarrow Y).f[U]x = }$ \\
$ \mathtt{ = (\lambda x:[X \mapsto U]T.\lambda Y::\ast.\lambda f:(\forall X::K.T \rightarrow Y).f[U]x)t = }$ \\
$ \mathtt{ \overset{t:[X \mapsto U]T}{=} \lambda Y::\ast.\lambda f:(\forall X::K.T \rightarrow Y).f[U](t:[X \mapsto U]T)}$ \\
co jest typu $\mathtt{\forall Y::\ast.(\forall X::K.T \rightarrow Y) \rightarrow Y}$, czyli z definicji $\mathtt{\{\exists X::K,T\}}$. \\

Rozważmy bardziej życiowy przykład, aby Czytelnik mógł jeszcze raz przeanalizować pakowanie. Oto typowanie w systemie $F$ przykładowego termu:\\ 
 	\[\mathtt{ \frac{\Gamma \vdash \{a=zero, f:\lambda x:Nat.succ\;x\}:[X \mapsto Nat]\{a:X,f:X \rightarrow Nat\}}{\Gamma \{^*X,\{a=zero, f:\lambda x:Nat.succ\;x\}\}\;as\;\{\exists X,\{a:X,f:X \rightarrow Nat\}\}}
		}
	\]
Następnie wyprowadzimy ten term w $F_\omega$: \\ \\
\small{
$ \mathtt{ \{Nat::K,\{a=zero, f:\lambda x:Nat.succ\;x\}\}\;as\; \{\exists X::K,\{a:X, f:X \rightarrow Nat\}\}= }$ \\ 
$ \mathtt{ = let\;x=\{a=zero, f:\lambda x:Nat.succ\;x\}\;in\;\lambda Y::\ast.\lambda f:(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y).f[Nat]x = }$ \\
$ \mathtt{ = (\lambda x:[X \mapsto Nat]\{a:X, f:X \rightarrow Nat\}.\lambda Y::\ast.\lambda f:(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y).f[Nat]x)}$\\
$ \mathtt{ \{a=zero, f:\lambda x:Nat.succ\;x\} \overset{\{a=zero, f:\lambda x:Nat.succ\;x\}:[X \mapsto Nat]\{a:X, f:X \rightarrow Nat\}}{=}  }$ \\
$ \mathtt{ = \lambda Y::\ast.\lambda f:(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y).f[Nat]\{a=zero, f:\lambda x:Nat.succ\;x\}}$ \\ \\
co jest typu $\mathtt{\forall Y::\ast.(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y) \rightarrow Y}$, czyli z definicji $\mathtt{\{\exists X::K,\{a:X, f:X \rightarrow Nat\}\}}$. \\
}

\normalsize{Uważne odpakowanie otrzymanego termu pozostawiamy Czytelnikowi jako ćwiczenie, my pozwolimy sobie przeprowadzać schemat wywodu:}\\
\scriptsize{
$ \mathtt{let\;\{X,x\}=\lambda Y::\ast.\lambda f:(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y).f[Nat]\{a=zero, f:\lambda x:Nat.succ\;x\}\;in\;(x.f\;x.a)=}$ \\
$ \mathtt{=(\lambda Y::\ast.\lambda f:(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y).f[Nat]\{a=zero, f:\lambda x:Nat.succ\;x\})[T'](\lambda X::K.\lambda x:T.(x.f\;x.a))=}$\\
}
$ \mathtt{=((\lambda X::K.\lambda x:T.(x.f\;x.a))[Nat](\{a=zero, f:\lambda x:Nat.succ\;x\}:[X \mapsto Nat]\{a:X, f:X \rightarrow Nat\}))=}$ \\
$ \mathtt{=(\{a=zero, f:\lambda x:Nat.succ\;x\}.f\;\{a=zero, f:\lambda x:Nat.succ\;x\}.a)=}$ \\
$ \mathtt{=(\lambda x:Nat.succ\;x)zero=succ\;zero}$ \\ 


\normalsize{
Przykłady powyższe obrazują działanie zakodowanych typów rekurencyjnych. Teraz zdefiniujemy wbudowane w język konstrukcje typów rekurencyjnych dla systemu $F_\omega$. Do definicji termów, typów i wartości dodaliśmy już elementy w tabelce na początku rozdziału. Pokażemy, w jaki sposób przebiega typowanie i ewaluacja. \\
}


Tworzenie rodzaju:
 	\[\mathtt{ \frac{a\;tutaj\;co?}{\Gamma \vdash \{\exists X::K,T\}::K}
		}
	\]
Typowanie:
 	\[\mathtt{ \frac{\Gamma \vdash t:[X \mapsto U]T\hspace{2em}\Gamma \vdash U::K \hspace{2em}\Gamma \vdash \{\exists X::K,T\}::\ast}{\Gamma \vdash \{^*U::K,t\}\;as\;\{\exists X::K,T\} \; : \; \{\exists X::K,T\}}
		}
	\]
 	\[\mathtt{ \frac{\Gamma \vdash t_1:\{\exists X::K,T_1\}\hspace{2em}\Gamma,X::K,x:T_1 \vdash t_2:T_2}{\Gamma \vdash let\;\{X,x\}=t_1\;in\;t_2:T_2}
		}
	\]
Ewaluacja:
 	\[\mathtt{ let\;\{X,x\}=(\{^*U::K,v\}\;as\;T)\;\;in\;t \longrightarrow [X \mapsto U][x \mapsto v]t
		}
	\]
 	\[\mathtt{ \frac{t \longrightarrow t'}{\{^*U::K,t\}\;as\;T \longrightarrow \{^*U::K,t'\}\;as\;T}
		}
	\]
 	\[\mathtt{ \frac{t_1\longrightarrow t_1'}{let\;\{X,x\}=t_1\;\;in\;t_2 \longrightarrow let\;\{X,x\}=t_1'\;\;in\;t_2}
		}
	\]
\subsection{Typy rekurencyjne}

Hmmm, no tu musze się zastanowić, to na dole dla zwykłej wersji. \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{fold[T]\;t}$ & \textit{folding} \\
   & $\mathtt{unfold[T]\;t}$ & \textit{unfolding}\\
   & & \\
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{\mu X.T}$ & \textit{typ rekursywny} \\
   & & \\
  $\mathtt{v}$ ::= & $\dots$ & \textit{wartości}  \\
   & $\mathtt{fold[T]\;v}$ & \textit{folding} \\
  \hline  
\end{tabular} \\
Tworzenie rodzaju:
 	\[\mathtt{\frac{}{\Gamma \vdash \mu X.T::\ast}
		}
	\]
Typowanie:
 	\[\mathtt{ \frac{ U=\mu X.T \hspace{2em} \Gamma \vdash t:[X\mapsto U]U}{\Gamma \vdash fold[U]\;t\; : U}
		}
	\]
Ewaluacja:
 	\[\mathtt{
		}
	\]

\subsection{dopasowanie wzorca}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rekonstrukcja typów}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Kilka słów o składni.}


Rozważmy język o składni:

\begin{tabular}{| l c r |}
  \hline
  t ::= &  &  \\
   & $x$ & \textit{zmienne}  \\
   & $\lambda x:T.t$ & \textit{abstrakcja (anotowana)} \\
   & $\lambda x.t$ & \textit{abstrakcja (nieanotowana)} \\
   & $t\;t$ & \textit{aplikacja} \\
   & $\Delta X::K.t$ & \textit{abstrakcja typowa (anotowana)} \\
   & $\Delta X.t$ & \textit{abstrakcja typowa (nieanotowana)} \\
   & $t[T]$ & \textit{aplikacja typowa} \\
   & $\textrm{let} \ x = t \ \textrm{in} \ t$ & \textit{zmienna lokalna} \\
   & $\textrm{tlet} \ X = T \ \textrm{in} \ t$ & \textit{typ lokalny} \\
   & & \\
  T ::= &  &  \\
   & $X$ & \textit{zmienna typowa (kwantyfikowana abstrakcją)} \\
   & $T \rightarrow T$ & \textit{typ funkcji} \\
   & $\forall X::K.T$ & \textit{typ uniwersalny (anotowany)} \\
   & $\forall X.T$ & \textit{typ uniwersalny (nieanotowany)} \\
   & $\Lambda X::K.T$ & \textit{konstruktor abstrakcji typowej (anotowany)} \\
   & $\Lambda X.T$ & \textit{konstruktor abstrakcji typowej (nieanotowany)} \\
   & $T\;T$ & \textit{aplikacja konstruktora typowego} \\
   & $\bar{X}$ & \textit{zmienna typowa (kwantyfikowana schematem)} \\
   & & \\
  K ::= & & \\
   & $*$ & \textit{rodzaj wszystkich typów} \\
   & $K \Rightarrow K$ & \textit{rodzaj funkcji typowej} \\
   & $\widehat{X}$ & \textit{zmienna rodzajowa (kwantyfikowana schematem)} \\
   & & \\
  \hline
\end{tabular} \\

Ważnym założeniem jest to, że $\bar{X}::*$, co nam ułatwi sprawę przy unifikacji, a~zarazem zbytnio nie ograniczy języka.
  
Jeżeli chcemy dodać ML-polimorfizm, będą nam portrzebne schematy typów i schematy rodzajów:

\begin{tabular}{| l c r |}
  \hline
  $\left<T\right>$ ::= &  & \textit{schemat typu} \\
   & $T$ & \textit{typ schematu} \\
   & $\Omega \bar{X}.\left<T\right>$ & \textit{kwantyfikacja zmiennej typowej} \\
   & $\Omega \widehat{X}.\left<T\right>$ & \textit{kwantyfikacja zmiennej rodzajowej} \\
   & & \\
  $\left<K\right>$ ::= &  & \textit{schemat rodzaju} \\
   & $K$ & \textit{rodzaj schematu}\\
   & $\Omega \widehat{X}.\left<K\right>$ & \textit{kwantyfikacja zmiennej rodzajowej} \\
   & & \\
  \hline
\end{tabular} \\

Będziemy używać następującego cukru syntaktycznego:
\[
\Omega \bar{X}_1 \dots \bar{X}_n \widehat{X}_1 \dots \widehat{X}_m.T \equiv 
\Omega \bar{X}_1. \dots \Omega \bar{X}_n. \Omega \widehat{X}_1. \dots \Omega \widehat{X}_m.T
\]
I analogicznie dla rodzajów.

Teraz sam kontekst typowania ma postać:

\begin{tabular}{| l c r |}
  \hline
  $\Gamma$ ::= &  & \\
   & $\emptyset$ & \\
   & $\Gamma, x:\left<T\right>$ & \\
   & $\Gamma, X::\left<K\right>$ & \\
   & & \\
  \hline
\end{tabular} \\

\subsection{$\beta$-unifikacja}

Podczas rekonstukcji typów pojawiają się równania więzów które należy rozwiązać. Samo rozwiązanie
sprowadza się do unifikacji pewnych termów, ale tutaj, ze względu na możliwość występowania funkcji
typowych, termy równoważne nie muszą być równe, więc sama unifikacja powinna sprowadzać termy do
$\beta$-równych sobie.

Taka unifikacja niesie ze sobą wiele problemów. Po pierwsze, będziemy chcieli używać podstawienia,
będącego unifikatorem, na innych termach. To zaś grozi uzewnętrznieniem zmiennych związanych. Drugi
problem to taki, że samo podstawienie nie musi zrównywać termów, które da się zrównać, ale różnią się
nazwami zmiennych związanych.

Z pierwszym problemem poradzimy sobie, traktując podstawienia jako funkcję częściowe, tzn. samo podstawienie
oprócz przyporzątkowań postaci $[\bar{X} := T]$, może również zawierać podstawienia postaci $[\bar{X} := fail]$.
Oraz dodając jeszcze operację anulowania podstawienia:
\[
[\bar{X} := T] \setminus X = 
\begin{cases}
[\bar{X} := fail] & X \in    Var(T) \\
[\bar{X} := T]    & X \notin Var(T)
\end{cases}
\]

Z drugim problemem poradzimy sobie traktując unifikator jako parę zawierającą podstawienie, które dobrze działa
na zewnątrz, oraz term będący wynikiem unifikacji.

\begin{definicja}
\emph{$\beta$-unifikatorem} dla konstruktorów typów $T_1$ i $T_2$ nazwiemy taką parę $(\sigma, S)$, że istnieją
podstawienia $\theta_1$ i $\theta_2$ takie, że:
\[
\theta_1 T_1 =_\beta S =_\beta \theta_2 T_2
\]
oraz
\[
\theta_1 \setminus BTV(T_1) = \sigma = \theta_2 \setminus BTV(T_2)
\]
\end{definicja}

\begin{definicja}
Powiemy, że $\beta$-unifikator $(\sigma, S)$ jest \emph{ogólniejszy} od $\beta$-unifikatora
$(\theta, T)$, jeżeli istnieje takie podstawienie $\rho$ i przemianowanie $\alpha$, że
\[
\rho\alpha S =_\beta T \quad \textrm{oraz} \quad \rho\alpha\sigma = \theta
\]
\end{definicja}

\begin{definicja}
\emph{Najogólniejszym $\beta$-unifikatorem} dla konstruktorów typów $T_1$ i $T_2$ nazwiemy taki $\beta$-unifikator,
który jest ogólniejszy od wszystkich innych $\beta$-unifikatorów tychże konstruktorów typów.
\end{definicja}

\begin{lemat}
Niech $A$ i $B$ będą podzbiorami zbioru zmiennych typowych kwnatyfikowanych abstrakcją, niech $\theta$ będzie podstawieniem.
Wówczas zachodzi
\[
(\theta \setminus A) \setminus B = \theta \setminus (A \cup B).
\]
\label{lsub0}
\end{lemat}
\begin{proof}
\end{proof}

\begin{lemat}
Niech $A$ będzie podzbiorem zbioru zmiennych typowych kwnatyfikowanych abstrakcją, niech $\theta$ i~$\rho$ będą podstawieniami, oraz
niech zachodzi $Var(\rho) \cap A = \emptyset$. Wówczas zachodzi 
\[
(\rho \circ \theta) \setminus A = \rho \circ (\theta \setminus A)
\].
\label{lsub1}
\end{lemat}
\begin{proof}
\end{proof}

\begin{lemat}
Niech $A$ będzie podzbiorem zbioru zmiennych typowych kwnatyfikowanych abstrakcją, niech $\theta$ będzie dowolnym podstawieniem,
niech $\rho$ będzie podstawieniem takim, że $Var(\rho) \cap A = \emptyset$ (w~szczególności zawierającym tylko zmienne rodzajowe). 
Wówczas zachodzi
\[
(\theta \circ \rho) \setminus A = (\theta \setminus A) \circ \rho
\]
\label{lsub2}
\end{lemat}
\begin{proof}
\end{proof}

\begin{lemat}
Niech $(\sigma, S)$ będzie $\beta$-unifikatorem dla konstruktorów typów $T_1$ i~$T_2$, oraz niech $\rho$ będzie 
podstawieniem takim, że $Var(\rho) \cap BTV(T_1) = \emptyset$ oraz $Var(\rho) \cap BTV(T_2) = \emptyset$.
Wówczas $(\rho \circ \sigma, \rho S)$ również jest $\beta$-unifikatorem dla konstruktorów typów $T_1$ i~$T_2$.
\label{lunif1}
\end{lemat}
\begin{proof}
Wiemy, że istnieją takie $\theta_1$ i~$\theta_2$, że
\[
\theta_1 T_1 =_\beta S =_\beta \theta_2 T_2 \quad \textrm{oraz} \quad \theta_1 \setminus BTV(T_1) = \sigma = \theta_2 \setminus BTV(T_2)
\]
A wtedy zachodzi
\[
(\rho \circ \theta_1)T_1 = \rho(\theta_1 T_1) =_\beta \rho S =_\beta \rho(\theta_2 T_2) = (\rho \circ \theta_2)T_2
\]
oraz z lematu \ref{lsub1}
\[
(\rho \circ \theta_1) \setminus BTV(T_1) = \rho \circ (\theta_1 \setminus BTV(T_1)) = \rho \circ \sigma
\]
\[
(\rho \circ \theta_2) \setminus BTV(T_2) = \rho \circ (\theta_2 \setminus BTV(T_2)) = \rho \circ \sigma
\]
\end{proof}

\begin{lemat}
Niech $T_1$ i~$T_2$ będą konstrktorami typów, $\rho$ niech będzie podstawieniem takim, że 
$Var(\rho) \cap BTV(T_1) = \emptyset$ oraz $Var(\rho) \cap BTV(T_2) = \emptyset$, a $(\sigma, S)$ niech będzie 
$\beta$-unifikatorem konstruktorów $(\rho T_1, \rho T_2)$.
Wówczas $(\sigma \circ \rho, S)$ jest $\beta$-unifikatorem konstruktorów $(T_1, T_2)$.
\label{lunif2}
\end{lemat}
\begin{proof}
Niech $i \in \left\{1,2\right\}$.\\
Z tego, że $(\sigma, S)$ jest $\beta$-unifikatorem konstruktorów $(\rho T_1, \rho T_2)$ wiemy, że istnieje takie
$\theta_i$, że
\[
\theta_i\rho T_i =_\beta S \quad \textrm{oraz} \quad \theta_i \setminus BTV(\rho T_i) = \sigma
\]
A~wtedy
\[
(\theta_i \circ \rho) T_i =_\beta S
\]
oraz z~lematu \ref{lsub2} i~z~tego że $BTV(\rho) \cap BTV(\theta_i) = \emptyset$ mamy
\[
(\theta_i \circ \rho) \setminus BTV(T_i) = (\theta_i \circ BTV(T_i)) \circ \rho = (\theta_i \circ BTV(\rho T_i)) \circ \rho = \sigma \circ \rho
\]
Co kończy dowód.
\end{proof}

\subsubsection{Algorytm $\beta$-unifikacji}

Przy unifikacji wszystkie nieanotowane kwantyfikatory traktujemy jak anotowane unikatową zmienną.
Funkcja $unify$ to klasyczna unifikacja (na rodzajach).\\
\begin{tabular}{l}
$unify_\beta(T_1, T_2) \ \textrm{when} \ T_1 =_\beta T_2 \ = $ \\
$\qquad ([], T_1)$ \\
\end{tabular} \\
\begin{tabular}{l}
$unify_\beta(\bar{X}, T) = $ \\
$\qquad \textrm{if} \ \bar{X} \in \bar{Var}(T) \ \textrm{then} \ fail $ \\
$\qquad \textrm{else} \ ([\bar{X} := T], T) $ \\
\end{tabular} \\
\begin{tabular}{l}
$unify_\beta(T, \bar{X}) = $ \\
$\qquad \textrm{if} \ \bar{X} \in \bar{Var}(T) \ \textrm{then} \ fail $ \\
$\qquad \textrm{else} \ ([\bar{X} := T], T) $ \\
\end{tabular} \\
\begin{tabular}{l}
$unify_\beta(\forall X_1::K_1.T_1, \forall X_2::K_2.T_2) = $ \\
$\qquad \textrm{let} \ \sigma_K = unify(K_1, K_2) \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma_T, T) = unify_\beta(\sigma_K T_1, \sigma_K \{X_2 := X_1\}T_2) \ \textrm{in} $ \\
$\qquad\qquad ((\sigma_T \setminus X_1) \circ \sigma_K, \forall X_1::\sigma_T \sigma_K K_1.T) $ \\
\end{tabular} \\
\begin{tabular}{l}
$unify_\beta(\Lambda X_1::K_1.T_1, \Lambda X_2::K_2.T_2) = $ \\
$\qquad \textrm{let} \ \sigma_K = unify(K_1, K_2) \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma_T, T) = unify_\beta(\sigma_K T_1, \sigma_K \{X_2 := X_1\}T_2) \ \textrm{in} $ \\
$\qquad\qquad ((\sigma_T \setminus X_1) \circ \sigma_K, \Lambda X_1::\sigma_T \sigma_K K_1.T) $ \\
\end{tabular} \\
\begin{tabular}{l}
$unify_\beta(T_1 \rightarrow S_1, T_2 \rightarrow S_2) = $ \\
$\qquad \textrm{let} \ (\theta, T) = unify_\beta(T_1, T_2) \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma, S) = unify_\beta(\theta S_1, \theta S_2) \ \textrm{in} $ \\
$\qquad\qquad (\sigma \circ \theta, \sigma T \rightarrow S) $ \\
\end{tabular} \\
\begin{tabular}{l}
$unify_\beta(T_1, T_2) \ \textrm{when} \ T_1 \longrightarrow_\beta S_1 \ = $ \\
$\qquad unify_\beta(S_1, T_2)$ \\
\end{tabular} \\
\begin{tabular}{l}
$unify_\beta(T_1, T_2) \ \textrm{when} \ T_2 \longrightarrow_\beta S_2 \ = $ \\
$\qquad unify_\beta(T_1, S_2)$ \\
\end{tabular} \\
\begin{tabular}{l}
$unify_\beta(V_1 \; T_1, V_2 \; T_2) = $ \\
$\qquad \textrm{let} \ (\theta, V) = unify_\beta(V_1, V_2) \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma, T) = unify_\beta(\theta T_1, \theta T_2) \ \textrm{in} $ \\
$\qquad\qquad (\sigma \circ \theta, \sigma V \; T) $ \\
\end{tabular} \\

\subsubsection{Własności}

\begin{fakt}
Algorytm $unify_\beta$ dla konstruktorów typów, dla których daje się określić rodzaj, zatrzymuje się.
\end{fakt}
\begin{proof}
Trywialne. Wynika z~tego, że algorytm jest sterowany składnią, oraz z~silnej normalizowalności kostruktorów typów.
\end{proof}
\begin{twierdzenie}
Niech $T_1$ oraz $T_2$ będą konstruktorami typów, które daje się orodzajować. Wówczas jeśli
$unify_\beta(T_1, T_2) = (\sigma, S)$, to $(\sigma, S)$ jest $\beta$-unifikatorem konstruktorów typów
$T_1$ i~$T_2$
\end{twierdzenie}
\begin{proof}
Indukcja po głebokości rekursji.

Możliwe są następujące przypadki:
\begin{itemize}
\item $T_1 =_\beta T_2$ lub $T_1 \equiv \bar{X}$ lub $T_2 \equiv \bar{X}$ \\
dla tych przypadków teza zachodzi trywialnie.
\item $T_1 \equiv \forall X_1::K_1.T'_1$ oraz $T_2 \equiv \forall X_2::K_2.T'_2$ \\
Wtedy z załorzenia indukcyjnego $(\sigma_T, T)$ jest $\beta$-unifikatorem konstruktorów typów
$\sigma_K T'_1$ oraz $\sigma_K\{X_2:=X_1\}T'_2$, gdzie $\sigma_K$ jest unifikatorem rodzajów $K_1$ i~$K_2$.
Istnieją więc takie podstawienia $\theta_1$ i~$\theta_2$, że zachodzą równości
\[
\theta_1 \sigma_K T'_1 =_\beta T =_\beta \theta_2 \sigma_K \{X_2:=X_1\} T'_2
\]
\[
\theta_1 \setminus BTV(\sigma_K T'_1) = \sigma_T = \theta_2 \setminus BTV(\sigma_K \{X_2:=X_1\} T'_2)
\]
A wtedy
\[
(\theta_1 \circ \sigma_K)\forall X_1::K_1.T'_1 = \forall X_1::\theta_1\sigma_K K_1. \theta_1\sigma_K T'_1 =_\beta
\]
\[
=_\beta \forall X_1::(\theta_1 \setminus BTV(\sigma_K T'_1))\sigma_K K_1.T = \forall X_1::\sigma_T\sigma_K K_1.T
\]
oraz
\[
(\theta_1 \circ \sigma_K) \setminus BTV(\forall X_1::K_1.T'_1) = (\theta_1 \setminus (\{X_1\} \cup BTV(\sigma_K T'_1))) \circ \sigma_K =
\]
\[
= (\sigma_T \setminus X_1) \circ \sigma_K
\]
Analogicznie pokarzemy pozostałe dwie równości dla konstruktora $T_2$. Zatem 
$((\sigma_T \setminus X_1) \circ \sigma_K, \forall X_1::\sigma_T \sigma_K K_1.T)$ jest $\beta$-unifikatorem konstruktorów $T_1$ i~$T_2$.
\item $T_1 \equiv \Lambda X_1::K_1.T'_1$ oraz $T_2 \equiv \Lambda X_2::K_2.T'_2$ \\
Dla tego przypadku dowód przeprowadzamy analogicznie do przypadku poprzedniego.
\item $T_1 \equiv T'_1 \rightarrow S_1$ oraz $T_2 \equiv T'_2 \rightarrow S_2$ \\
Teza wynika wprost z załorzenia indukcyjnego oraz lematów \ref{lunif1} i \ref{lunif2}.
\item $T_1 \longrightarrow_\beta S_1$ lub $T_2 \longrightarrow_\beta S_2$ \\
Wynika z~załorzenia indukcyjnego i~z~faktu, że $\beta$-redukcja zachowuje $\beta$-równość.
\item $T_1 \equiv V_1\;S_1$ oraz $T_2 \equiv V_2\;S_2$ \\
Dowód przeprowadzamy analogicznie do przypadku z typem funkcji.
\end{itemize}
\end{proof}

\begin{fakt}
Algorytm $unify_\beta$ działający na konstruktorach typów nie zawierających zmiennych schematowych
zwraca pusty unifikator jeśli konstruktory są $\beta$ równe, w~przeciwnym przypadku zawodzi (zawraca $fail$).
\end{fakt}
\begin{proof}
\end{proof}

\begin{fakt}
Jeżeli z~algorytmu usuniemy pierwszy przypadek sprawdzający $\beta$-równość konstruktorów, otrzymamy algorytm
równoważny.
\end{fakt}
\begin{proof}
\end{proof}

Tu powinno pojawić się jeszcze kilka dowodów własności.

\subsection{Rekonstrukcja typów}

\subsubsection{Algorytm W}

Dla rodzajów: \\
\begin{tabular}{l}
$kindof(\Gamma \vdash X :: ?) = $ \\
$\qquad \textrm{let} \ \Omega \widehat{X}_1 \dots \widehat{X}_n.K = \Gamma(X) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \widehat{Y}_1, \dots, \widehat{Y}_n = fresh \ \textrm{in} $ \\
$\qquad\qquad ([], [\widehat{X}_1 := \widehat{Y}_1, \dots ,\widehat{X}_n := \widehat{Y}_n]K) $ \\
\end{tabular} \\
\begin{tabular}{l}
$kindof(\Gamma \vdash T_1 \rightarrow T_2 :: ?) = $ \\
$\qquad \textrm{let} \ (\sigma_1, K_1) = kindof(\Gamma \vdash T_1 :: ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma_2, K_2) = kindof(\sigma_1 \Gamma \vdash \sigma_1 T_1 :: ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \rho_1 = unify(\sigma_2 K_1, *) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \rho_2 = unify(\rho_1 K_2, *) \ \textrm{in} $ \\
$\qquad\qquad (\rho_2 \circ \rho_1 \circ \sigma_2 \circ \sigma_1, *) $ \\
\end{tabular} \\
\begin{tabular}{l}
$kindof(\Gamma \vdash \forall X::K.T :: ?) = $ \\
$\qquad \textrm{let} \ (\sigma, K_T) = kindof(\Gamma, X::K \vdash T :: ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \rho = unify(K_T, *) \ \textrm{in} $ \\
$\qquad\qquad (\rho \circ \sigma, *) $ \\
\end{tabular} \\
\begin{tabular}{l}
$kindof(\Gamma \vdash \Lambda X::K.T :: ?) = $ \\
$\qquad \textrm{let} \ (\sigma, K_T) = kindof(\Gamma, X::K \vdash T :: ?) \ \textrm{in} $ \\
$\qquad\qquad (\sigma, K \Rightarrow K_T) $ \\
\end{tabular} \\
\begin{tabular}{l}
$kindof(\Gamma \vdash T_1 \; T_2 :: ?) = $ \\
$\qquad \textrm{let} \ (\sigma_1, K_1) = kindof(\Gamma \vdash T_1 :: ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma_2, K_2) = kindof(\sigma_1 \Gamma \vdash \sigma_1 T_2 :: ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \widehat{X} = fresh \ \textrm{in} $ \\
$\qquad \textrm{let} \ \sigma_3 = unify(\sigma_2 K_1, K_2 \Rightarrow \widehat{X}) \ \textrm{in} $ \\
$\qquad\qquad (\sigma_3 \circ \sigma_2 \circ \sigma_1, \sigma_3 \widehat{X}) $ \\
\end{tabular} \\
\begin{tabular}{l}
$kindof(\Gamma \vdash \bar{X} :: ?) = $ \\
$\qquad\qquad ([], *) $ \\
\end{tabular} \\

Dla typów:\\
\begin{tabular}{l}
$typeof(\Gamma \vdash x : ?) = $ \\
$\qquad \textrm{let} \ \Omega \bar{X}_1 \dots \bar{X}_n \widehat{X}_1 \dots \widehat{X}_m.T = \Gamma(x) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \bar{Y}_1, \dots, \bar{Y}_n, \widehat{Y}_1, \dots, \widehat{Y}_m = fresh \ \textrm{in} $ \\
$\qquad\qquad ([], [\bar{X}_1 := \bar{Y}_1, \dots ,\bar{X}_n := \bar{Y}_n,\widehat{X}_1 := \widehat{Y}_1, \dots ,\widehat{X}_m := \widehat{Y}_m]T) $ \\
\end{tabular} \\
\begin{tabular}{l}
$typeof(\Gamma \vdash \lambda x:T.t : ?) = $ \\
$\qquad \textrm{let} \ (\sigma_1, K) = kindof(\Gamma \vdash T :: ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \sigma_2 = unify(K, *) \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma_3, T_t) = typeof(\sigma_2 \sigma_1(\Gamma, x:T) \vdash \sigma_2 \sigma_1 t : ?) \ \textrm{in} $ \\
$\qquad\qquad (\sigma_3 \circ \sigma_2 \circ \sigma_1, \sigma_3 \sigma_2 \sigma_1 T \rightarrow T_t) $ \\
\end{tabular} \\
\begin{tabular}{l}
$typeof(\Gamma \vdash t_1 \; t_2 : ?) = $ \\
$\qquad \textrm{let} \ (\sigma_1, T_1) = typeof(\Gamma \vdash t_1 : ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma_2, T_2) = typeof(\sigma_1 \Gamma \vdash \sigma_1 t_2 : ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \bar{X} = fresh \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma_3, T_3) = unify_\beta(\sigma_2 T_1, T_2 \rightarrow \bar{X}) \ \textrm{in} $ \\
$\qquad\qquad (\sigma_3 \circ \sigma_2 \circ \sigma_1, \sigma_3 \bar{X}) $ \\
\end{tabular} \\
\begin{tabular}{l}
$typeof(\Gamma \vdash \Delta X::K.t : ?) = $ \\
$\qquad \textrm{let} \ (\sigma, T) = typeof(\Gamma, X::K \vdash t : ?) \ \textrm{in} $ \\
$\qquad\qquad (\sigma \setminus X, \forall X::\sigma K.T) $ \\
\end{tabular} \\
\begin{tabular}{l}
$typeof(\Gamma \vdash t[T] : ?) = $ \\
$\qquad \textrm{let} \ (\sigma_1, T_t) = typeof(\Gamma \vdash t : ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma_2, K) = kindof(\sigma_1 \Gamma \vdash \sigma_1 T :: ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \bar{X} = fresh \ \textrm{in} $ \\
$\qquad \textrm{let} \ Y = fresh \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma_3, T'_t) = unify_\beta(\sigma_2 T_t, \forall Y::K.\bar{X}) \textrm{in} $ \\
$\qquad\qquad (\sigma_3 \circ \sigma_2 \circ \sigma_1, [Y:=\sigma_3 \sigma_2 \sigma_1 T]\sigma_3\bar{X}) $ \\
\end{tabular} \\
\begin{tabular}{l}
$typeof(\Gamma \vdash \textrm{let} \ x=t_1 \ \textrm{in} \ t_2 : ?) = $ \\
$\qquad \textrm{let} \ (\sigma_1, T_1) = typeof(\Gamma \vdash t_1 : ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \left\{ \bar{X}_1, \dots, \bar{X}_n \right\} = \bar{FTV}(T_1) \setminus \bar{FTV}(\Gamma) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \left\{ \widehat{X}_1, \dots, \widehat{X}_m \right\} = \widehat{FKV}(T_1) \setminus \widehat{FKV}(\Gamma) \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma_2, T_2) = typeof(\sigma_1 \Gamma, x:\Omega \bar{X}_1 \dots \bar{X}_n \widehat{X}_1 \dots \widehat{X}_m. T_2 \vdash \sigma_1 t_2 : ?) \ \textrm{in} $ \\
$\qquad\qquad (\sigma_2 \circ \sigma_1, T_2) $ \\
\end{tabular} \\
\begin{tabular}{l}
$typeof(\Gamma \vdash \textrm{tlet} \ X=T \ \textrm{in} \ t : ?) = $ \\
$\qquad \textrm{let} \ (\sigma_1, K) = kindof(\Gamma \vdash T :: ?) \ \textrm{in} $ \\
$\qquad \textrm{let} \ \left\{ \widehat{X}_1, \dots, \widehat{X}_m \right\} = \widehat{FKV}(K) \setminus \widehat{FKV}(\Gamma) \ \textrm{in} $ \\
$\qquad \textrm{let} \ (\sigma_2, T_t) = typeof(\sigma_1 \Gamma, X::\Omega \widehat{X}_1 \dots \widehat{X}_m.K \vdash \sigma_1 t : ?) \ \textrm{in} $ \\
$\qquad\qquad (\sigma_2 \circ \sigma_1, T_t) $ \\
\end{tabular} \\

Tu można wspomnieć o jego własnościach.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Własności i dowody}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}

\subsection{Inne własności $F_\omega$}

\begin{definicja}
Reguły przepisywania typów w systemie $F_{\omega}$ w wersji Curry'ego standardowe, oprócz: \\

$\frac{\Gamma \vdash M : \forall X \sigma}{\Gamma \vdash M : nf(\sigma [ X := \tau ])}$

\end{definicja}


Nierozstzygalne są problemy:
    \begin{itemize}
        \item sprawdzania typu: dane $\Gamma, M, \tau$, Czy $\Gamma \vdash M : \tau$
        \item typowalność: dane M, Czy $\exists \Gamma \tau . \Gamma \vdash M : \tau$
    \end{itemize}


\subsection{pare słów o rozszerzeniach}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Praktyczne zastosowanie}                       
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Podsumowanie}                       
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliografia
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\thispagestyle{empty}
\begin{thebibliography}{99}

\bibitem{ChK} Pierce, \textit{} 


	  
\end{thebibliography}

\end{document}

