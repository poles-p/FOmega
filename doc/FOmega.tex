%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                            %%
%%                                              Wrocław, styczeń 2011 r.      %%
%%                                                                            %%
%%                                                                            %%
%%                                                                            %%
%%                                SYSTEMY TYPÓW - PROJEKT                     %%
%%                                                                            %%
%%                                   Piotr Polesiuk                           %%
%%                                Małgorzata Jurkiewicz                       %%
%%                                                                            %%
%%                                                                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[11pt,leqno]{article}

\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}


\usepackage{a4wide}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[pdftex]{graphicx}
\usepackage{caption}
\usepackage{bm}
\usepackage{amsthm}


 
%%%%%%%%%%%%%%%%%%
% Kropka po numerze paragrafu, podparagrafu itp. 

\makeatletter
 \renewcommand\@seccntformat[1]{\csname the#1\endcsname.\quad}
 \renewcommand\numberline[1]{#1.\hskip0.7em}
\makeatother

%%%%%%%%%%%%%%%%%%
% Kropka po numerze tablicy, rysunku i ustawienie czcionki dla etykiety. 

\captionsetup{labelfont=sc,labelsep=period}

%%%%%%%%%%%%%%%%%%
% Inna numeracja wzorów.

\renewcommand{\theequation}{\arabic{section}.\arabic{equation}}

%%%%%%%%%%%%%%%%%%

\title{{\textbf{System typów $F_{\omega}$}}\\[1ex]
       {\Large Systemy Typów 2010/11}\\[-1ex]
       {\large Prowadzący: dr Dariusz Biernacki}}
\author{Piotr Polesiuk \\ \texttt{bassists@o2.pl} 
   \and Małgorzata Jurkiewicz \\ \texttt{gosia.jurkiewicz@gmail.com}} 

\date{Wrocław, dnia \today\ r.}

\begin{document}
\thispagestyle{empty}
\maketitle

\pagebreak

\theoremstyle{plain}
\newtheorem{twierdzenie}{Twierdzenie}
\newtheorem{lemat}{Lemat}

\theoremstyle{definition}
\newtheorem{definicja}{Definicja}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Wstęp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}


No to na razie taki bałagan



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{System $F_{\omega}$}                                 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}

W rozdziale tym chcielibyśmy się skupić na systemie $F_{\omega}$ okrojonym do niezbędnego minimum.
Przedstawimy, jak wyglądają termy, typy i wartości tego języka, a także pokażemy, jak przebiega typowanie,
znajdowanie rodzaju, ewaluacja czy sprawdzanie równości typów. Postaramy się pisać jasno i pokażemy parę przykładów, 
aby nieobyty w temacie Czytelnik nie zgubił się.  W następnych rozdziałach XXX-XXX do tak zdefiniowanego systemu będziemy wprowadzać
rozszerzenia.

\subsection {Termy i typy w $F_\omega$}

System $F_{\omega}$ to rachunek będący rozszerzeniem $\lambda_{\omega}$ oraz systemu $F$.
Wszystkie trzy wywodzą się z rachunku lambda z typami prostymi. Termy oraz typy definiujemy w $\lambda_{\rightarrow}$ następująco: \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= &  & \textit{termy}  \\
   & $\mathtt{x}$ & \textit{zmienne}  \\
   & $\mathtt{\lambda x:T.t}$ & \textit{abstrakcja} \\
   & $\mathtt{t \hspace{0.2em} t}$ & \textit{aplikacja} \\
   & & \\
  $\mathtt{T}$ ::= &  & \textit{typy} \\
   & $\mathtt{X}$ & \textit{zmienna typowa} \\
   & $\mathtt{T \rightarrow T}$ & \textit{typ funkcji} \\
  \hline
\end{tabular} \\



\subsubsection{System $\lambda_{\omega}$} 

Główną cechą systemu $\lambda_{\omega}$ jest to, że oprócz termów zależnych od termów mamy typy zależne od typów, czyli możemy mówić o aplikacji i abstrakcji typowej, a tak powstałe 'typy' będziemy nazywać konstruktorami. By nam się nie pomyliło z abstrakcją na termach, zmienne konstruktorowe będziemy zaczynać dużą literą. Przykładowo $\mathtt{Tb=\lambda X.X \rightarrow Bool}$ i $\mathtt{\lambda X.X}$ są abstrakcjami konstruktowymi, ale $\mathtt{\lambda x.x}$ jest abstrakcją na termach. 
Do konstruktora $\mathtt{Tb}$ możemy zaaplikować $\mathtt{Bool}$ i dostaniemy $\mathtt{(\lambda X.X \rightarrow Bool)Bool}$ równoważne $\mathtt{Bool \rightarrow Bool}$. Jak widać, użyliśmy słowa \textit{równoważne}. W rachunku lambda z typami prostymi sposób konstrukcji typów gwarantował nam, że dwa typy $\mathtt{T_1}$ i $\mathtt{T_2}$ na pewno są różne (zakładając, że typy bazowe były sobie różne). W $\lambda_{\omega}$ jest inaczej -- konstruktory tego systemu możemy podzielić na klasy równoważności. Do klasy $\mathtt{Bool \rightarrow Bool}$ należą również $\mathtt{ (Tb^n) Bool }$ dla $n$ naturalnego, a $\mathtt{T^n}$ oznacza aplikację $n$ konstruktorów $\mathtt{T}$.
Zauważmy, że odpowiednikiem takiej relacji równoważności w $\lambda_{\rightarrow}$  jest $\beta$-równoważność. W~świecie typów nazwiemy taką relację $\equiv$\footnote{formalnie zdefiniujemy tą relację w rozdziale XXX}. Każdy konstruktor typu jest silnie normalizowalny i zachodzi własność Churcha-Rossera. Przez \texttt{nf(T)} oznaczamy postać normalną konstruktora rodzaju \texttt{T}.
Dodatkowo wprowadzimy następującą regułę:
$\mathtt{\frac{\Gamma \vdash t:S \hspace{1em} S\equiv T  }{\Gamma \vdash t:T}}$
mówiącą, że jeżeli \texttt{S} jest konstruktorem termu \texttt{t}, to dowolny konstruktor \texttt{S} równoważny z \texttt{T} również jest konstruktorem \texttt{t}.  

Niestety, w tak zdefiniowanym systemie powstaje jeden problem. Nie chcielibyśmy, aby $\mathtt{Bool \hspace{0.2em} Bool}$ było dozwolone, tak samo, jak w świecie termów nie chcieliśmy, by $\mathtt{true \hspace{0.2em} true}$ było dozwolone. W świecie termów, by rozwiązać ten problem, wprowadziliśmy typy na termach, w świecie typów wprowadzimy \textit{rodzaje} na konstruktorach. Piszemy, że $\mathtt{T::K}$, czyli konstruktor $\mathtt{T}$ jest rodzaju $\mathtt{K}$. Wprowadzimy też jeden rodzaj bazowy $\mathtt{\ast}$.

Wszystkie typy, jakie pojawiły się w $\lambda_{\rightarrow}$, są rodzaju $\mathtt{\ast}$. Np. $\mathtt{Bool :: \ast}$, $\mathtt{Nat \rightarrow Nat}$, $\mathtt{(Bool \rightarrow Nat) \rightarrow Nat} :: \ast$, itd. Rodzaj $\mathtt{\ast \Rightarrow \ast}$ będzie odpowiadał funkcjom z konstruktorów w konstruktory, np. $\mathtt{\lambda X.X \rightarrow Bool::\ast \Rightarrow \ast }$. $\mathtt{\ast \Rightarrow \ast \Rightarrow \ast}$ bierze konstruktor i zwraca funkcję konstruktorową, np. $\mathtt{\lambda X. \lambda Y. X \rightarrow Y::\ast \Rightarrow \ast \Rightarrow \ast}$, itd. 

Teraz możemy $\lambda_{\rightarrow}$ rozszerzyć o następujące konstrukcje: 
\begin{itemize}
    \item rodzaje \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{K}$ ::= &  & \textit{rodzaje}  \\
   & $\mathtt{\ast}$ & \textit{rodzaj wszystkich typów} \\
   & $\mathtt{K \Rightarrow K}$ & \textit{rodzaj funkcji typowej} \\
  \hline
\end{tabular}
    \item abstrakcję i aplikację typową na typach \\ \\
\begin{tabular}{| l c r |}
   \hline
   $\mathtt{T}$ ::= & $\cdots$ & \textit{typy}  \\
   & $\mathtt{\lambda X::K.T}$ & \textit{abstrakcja konstruktorowa} \\
   & $\mathtt{T\;T}$ & \textit{aplikacji konstruktorowa} \\
   \hline
\end{tabular}
\end{itemize} 

Powstaje pytanie, czy wszystkie konstruktory są typami? Otóż nie, typy to konstruktory rodzaju $\mathtt{\ast}$.

\subsubsection{System $F$}

System F jest systemem, w którym dodatkowo, oprócz termów zależnych od termów, mamy termy zależne od typów. Wprowadzimy trzeci już rodzaj abstrakcji i aplikacji, poprzedni był w świecie typów, ten będzie w świecie termów. Znana jest nam funkcja identycznościowa $\mathtt{\lambda x.x}$, w $\lambda_{\rightarrow}$ możemy ją napisać na wiele sposób: $\mathtt{\lambda x:Bool.x}$, $\mathtt{\lambda x:Nat.x}$, $\mathtt{\lambda x:Bool \rightarrow Nat.x}$. W systemie $F$ możemy wszystkie te funkcje zapisać jako: $\mathtt{\lambda X. \lambda x:X.x}$. Zauważmy, że ten \textit{term} przyjmuje jako pierwszy argument typ, następnie term tego typu i zwraca term. Przykładem użycia takiego termu mogą być: $(\mathtt{\lambda X. \lambda x:X.x)\;[Bool]\;true}$, co daje $\mathtt{true}$, albo $(\mathtt{\lambda X. \lambda x:X.x)\;[Nat]\;1}$, co daje $\mathtt{1}$. W ten sposób powstała nam \textit{uniwersalna} funkcja identycznościowa, której nadamy tzw. uniwersalny typ: $\mathtt{\lambda X. \lambda x:X.x \; : \; \forall X.X \rightarrow X}$. Dodatkowo, jako że dodaliśmy już do systemu rodzaje, napiszemy $\mathtt{\lambda X::\ast. \lambda x:X.x \; : \; \forall X::\ast.X \rightarrow X \; ::\ast}$. 

Czy moglibyśmy napisać $\mathtt{\lambda X::\ast \Rightarrow \ast. \lambda x:X.x \; : \; \forall X::\ast \Rightarrow \ast.X \rightarrow X \; ::\ast \Rightarrow \ast}\;$? Jak już mówiliśmy, tylko konstruktory rodzaju $\mathtt{\ast}$ są typami, więc powyższy term nie jest dobry.

Po tym krótkim wstępie możemy już zdefiniować odziedziczone z systemu $F$ własności takie, jak:  
\begin{itemize}
    \item abstrakcję i aplikację typową na termach \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\cdots$ & \textit{termy} \\
   & $\mathtt{\lambda X::K.t}$ & \textit{abstrakcja typowa} \\
   & $\mathtt{t[T]}$ & \textit{aplikacja typowa} \\
  \hline
\end{tabular}

    \item typ uniwersalny \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{T}$ ::= & $\cdots$ & \textit{typy}  \\
   & $\mathtt{\forall X::K.T}$ & \textit{typ uniwersalny} \\
  \hline
\end{tabular}

\end{itemize}


\subsection{Typowanie}

\subsubsection{Kontekst}

\emph{Kontekst typowania} opisany jest następującą składnią abstrakcyjną: \\

\begin{tabular}{ | l c r | }
	\hline
	$\mathtt{\Gamma}$ ::= & & \textit{kontekst}\\
	& $\mathtt{\emptyset}$ & \textit{pusty kontekst} \\
	& $\mathtt{\Gamma,x:T}$& \textit{wiązanie typu} \\ 
	& $\mathtt{\Gamma,X::K}$& \textit{wiązanie rodzaju} \\ 
	\hline
\end{tabular} \\
	
Konteksty typowania bedziemy często traktować jako skończone zbiory wiązań i będziemy
używać teoriomnogościowych symboli na nich. Np. przynależność do kontekstu formalnie
definiujemy jako:
\[
	\frac{}{B \in \Gamma,B}
	\qquad
	\frac{B \in \Gamma}{B \in \Gamma,B'}
\]
Definicje pozostałych operacji teoriomnogościowych są na tyle naturalne, że zostawiamy
je Czytelnikowi do uzupełnienia.


\subsubsection{Podstawienia}
Oprócz zwykłego podstawienia za zmienne, które pozostawiamy Czytelnikowi do uzupełnienia, powinniśmy zdefiniować podstawienie za zmienne konstruktorowe.

    \begin{itemize}
        \item $\mathtt{[Y \mapsto T]X = \begin{cases}  \texttt{T} & Y=X \\ \texttt{X} & \text{w.p.p} \end{cases}}$
        \item $\mathtt{[Y \mapsto T](X_1 \; X_2)  = [Y \mapsto T]X_1 [Y \mapsto T] X_2 }$
        \item $\mathtt{[Y \mapsto T](S_1 \rightarrow S_2) = [Y \mapsto T]S_1 \rightarrow [Y \mapsto T]S_2} $
        \item $\mathtt{[Y \mapsto T]\forall X.S}  = \begin{cases} \mathtt{\forall X.S} & Y=X \text{ lub } Y \notin FV(S) \\ \mathtt{\forall X.[Y \mapsto T]S} & X \notin FV(S)  \text{ i } Y \in FV(S) \end{cases}$
        \item $\mathtt{[Y := T]\lambda X.S }= \begin{cases} \mathtt{\lambda X.S} & Y=X \text{ lub } Y \notin FV(S)\\ \mathtt{\lambda X.[Y \mapsto T]S}  & X \notin FV(S)  \text{ i } Y \in FV(S) \end{cases}$
    \end{itemize}

\subsubsection{Relacja $\equiv$}

Jak wspomnieliśmy w rozdziale XXX, definiujemy na typach relację równoważności. W poniższych wzorach $\mathtt{S,S_1,S_2,T,T_1,T_2}$ to typy, \texttt{K} to rodzaj. Następujące trzy reguły:
	\[\mathtt{
		\frac{}{T \equiv T}
                \qquad
                \frac{S \equiv T}{T \equiv S}}
                \qquad
                \frac{S \equiv U \;\; U \equiv T}{S \equiv T}
	\]
gwarantują nam równoważność relacji $\equiv$. Pozostałe reguły jak następuje:
	\[\mathtt{
		\frac{S_1 \equiv T_1 \;\; S_2 \equiv T_2}{S_1 \rightarrow S_2 \equiv T_1 \rightarrow T_2}
                \qquad
                \frac{S_1 \equiv T_1 \;\; S_2 \equiv T_2}{S_1\;S_2 \equiv T_1\;T_2}}
	\]
	\[\mathtt{
		\frac{S \equiv T}{\lambda X::K.S \equiv \lambda X::K.T}
                \qquad
                (\lambda X::K.S)T \equiv [X \mapsto T]S}
	\] 

definiują równoważność funkcji typowych, aplikacji i abstrakcji konstruktorowych oraz typów uniwersalnych.

\subsubsection{Reguły rodzajowania}

W systemie $F_\omega$ każdemu poprawnie zbudowanemu typowi przyporządkowujemy rodzaj.
Przyporządkowanie to określa relacja $(.\vdash.::.)$ zdefiniowana następująco.

Jeżeli zachodzi $\mathtt{\Gamma \vdash T :: K}$, to powiemy, że
\emph {typ $\mathtt{T}$ jest rodzaju $\mathtt{K}$ w~kontekście $\mathtt{\Gamma}$}, gdzie
relacja określenia rodzaju $(.\vdash.::.) \subseteq \Gamma \times T \times K$
jest najmniejszą relacją zamkniętą na reguły:
	\[ \mathtt{
		\frac{X::K \in \Gamma}{\Gamma \vdash X::K}
		\qquad
		\frac{\Gamma \vdash T_1 :: K_{1} \Rightarrow K_{2} \hspace{1em} \Gamma \vdash T_2 :: K_{1}}{\Gamma \vdash T_1 T_2 :: K_{2}}}
	\]
	\[ \mathtt{
		\frac{\Gamma \vdash X :: K_1 \hspace{1em} \Gamma \vdash T :: K_2}{\Gamma \vdash \lambda X::K_1. T :: K_{1} \Rightarrow K_{2}}
		\qquad
		\frac{\Gamma \vdash X :: K \hspace{1em} \Gamma \vdash T :: \ast}{\Gamma \vdash \forall X::K. T :: \ast}}
	\]
	\[\mathtt{
		\frac{\Gamma \vdash T_1 : \ast \hspace{1em} \Gamma \vdash T_2 : \ast}{\Gamma \vdash T_1 \rightarrow T_2 : \ast}}
	\]	


\subsubsection{Reguły typowania}

Jesteśmy już gotowi przedstawić reguły typowania zdefiniowanego wyżej systemu $F_\omega$.
Każdemu poprawnie zbudowanemu termowi przyporządkowujemy typ. Przyporządkowanie to określa relacja $(.\vdash.:.)$ zdefiniowana następująco.

	\[\mathtt{
		\frac{x:T \in \Gamma}{\Gamma \vdash x:T}
                \qquad
                \frac{\Gamma \vdash T_1::\ast \hspace{1.5em} \Gamma,x:T_1 \vdash t_2:T_2}{\Gamma \vdash \lambda x:T_1.t_2\;:\;T_1 \rightarrow T_2}}
	\]
	\[\mathtt{
		\frac{\Gamma \vdash t_1:T_1 \rightarrow T_2 \hspace{1.5em} \Gamma \vdash t_2:T_1}{ \Gamma \vdash t_1 \; t_2 : T_2}
                \qquad
                \frac{\Gamma \vdash t:S \hspace{1.5em} S \equiv T \hspace{1.5em} \Gamma \vdash T::\ast}{\Gamma \vdash t:T}}
	\]

\subsection{Ewaluacja}

Wartości w $F_\omega$ zdefiniujemy dokładnie jak w $\lambda_{\rightarrow}$. \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{v}$ ::= &  & \textit{wartości}  \\
   & $\mathtt{\lambda x:T.t}$ & \textit{wartość abstrakcji} \\
  \hline
\end{tabular} \\

Ewaluacja przebiega w sposób standardowy. W rozdziałach XXX-XXX skupimy się na rozszerzeniach minimalnej wersji $F_\omega$ i pojawią się tam nowe rzeczy. Teraz, dla czytelności, przetoczymy reguły ewaluacji dla wersji minimalnej ($\mathtt{t_1,t_1',t_2,t_2',t}$ to termy, \texttt{v} to wartość, \texttt{x:T} to zmienna \texttt{x} typu \texttt{T}):
	\[\mathtt{
		\frac{t_1 \longrightarrow t_1'}{t_1\;t_2 \longrightarrow t_1'\;t_2}
                \qquad
                \frac{t_2 \longrightarrow t_2'}{v_1\;t_2 \longrightarrow v_1\;t_2'}}
	\]
 	\[\mathtt{
		(\lambda x:T.t)v \longrightarrow [x \mapsto v]t}
	\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Własności i dowody}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}

\begin{twierdzenie}[Progres]
Niech $t$ będzie termem nie będącym wartością, oraz niech $\Gamma$ oraz $T$ będą
kontekstem typowania i~typem, takim że zachodzi $\Gamma\vdash t : T$. Wówczas istnieje
taki term $t'$, że $t \longrightarrow_\beta t'$.
\end{twierdzenie}
\begin{proof}
\end{proof}

\begin{twierdzenie}[Zachowanie typu]
Niech zachodzi $\Gamma \vdash t:T$, oraz $t \longrightarrow_\beta t'$ dla pewnych
$\Gamma$, $t$, $t'$ oraz $T$. Wówczas zachodzi
$\Gamma\vdash t' : T$.
\end{twierdzenie}
\begin{proof}
\end{proof}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Możliwe rozszerzenia}                                 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}


\subsection{wyrażenia arytmetyczne i logiczne}

\subsection{unit i sekwencje}
\subsection{definicje lokalne}
\subsection{Rekordy}
\subsection{warianty}
\subsection{punkt stały}
\subsection{listy}
\subsection{typy egzystencjalne}
\subsection{typy rekurencyjne}
\subsection{dopasowanie wzorca}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rekonstrukcja typów}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Inne własności $F_\omega$}

\begin{definicja}
Reguły przepisywania typów w systemie $F_{\omega}$ w wersji Curry'ego standardowe, oprócz: \\

$\frac{\Gamma \vdash M : \forall X \sigma}{\Gamma \vdash M : nf(\sigma [ X := \tau ])}$
\end{definicja}


Nierozstzygalne są problemy:
    \begin{itemize}
        \item sprawdzania typu: dane $\Gamma, M, \tau$, Czy $\Gamma \vdash M : \tau$
        \item typowalność: dane M, Czy $\exists \Gamma \tau . \Gamma \vdash M : \tau$
    \end{itemize}


\subsection{pare słów o rozszerzeniach}
\section{Praktyczne zastosowanie}                       
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Podsumowanie}                       
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliografia
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\thispagestyle{empty}
\begin{thebibliography}{99}

\bibitem{ChK} Pierce, \textit{} 


	  
\end{thebibliography}

\end{document}

