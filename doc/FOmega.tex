%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                            %%
%%                                              Wrocław, styczeń 2011 r.      %%
%%                                                                            %%
%%                                                                            %%
%%                                                                            %%
%%                                SYSTEMY TYPÓW - PROJEKT                     %%
%%                                                                            %%
%%                                   Piotr Polesiuk                           %%
%%                                Małgorzata Jurkiewicz                       %%
%%                                                                            %%
%%                                                                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[11pt,leqno]{article}

\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}


\usepackage{a4wide}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[pdftex]{graphicx}
\usepackage{caption}
\usepackage{bm}
\usepackage{amsthm}


 
%%%%%%%%%%%%%%%%%%
% Kropka po numerze paragrafu, podparagrafu itp. 

\makeatletter
 \renewcommand\@seccntformat[1]{\csname the#1\endcsname.\quad}
 \renewcommand\numberline[1]{#1.\hskip0.7em}
\makeatother

%%%%%%%%%%%%%%%%%%
% Kropka po numerze tablicy, rysunku i ustawienie czcionki dla etykiety. 

\captionsetup{labelfont=sc,labelsep=period}

%%%%%%%%%%%%%%%%%%
% Inna numeracja wzorów.

\renewcommand{\theequation}{\arabic{section}.\arabic{equation}}

%%%%%%%%%%%%%%%%%%

\title{{\textbf{System typów $F_{\omega}$}}\\[1ex]
       {\Large Systemy Typów 2010/11}\\[-1ex]
       {\large Prowadzący: dr Dariusz Biernacki}}
\author{Piotr Polesiuk \\ \texttt{bassists@o2.pl} 
   \and Małgorzata Jurkiewicz \\ \texttt{gosia.jurkiewicz@gmail.com}} 

\date{Wrocław, dnia \today\ r.}

\begin{document}
\thispagestyle{empty}
\maketitle

\pagebreak

\theoremstyle{plain}
\newtheorem{twierdzenie}{Twierdzenie}
\newtheorem{lemay}{Lemat}

\theoremstyle{definition}
\newtheorem{definicja}{Definicja}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Wstęp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}


No to na razie taki bałagan



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{System $F_{\omega}$}                                 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}

W rozdziale tym chcielibyśmy się skupić na systemie $F_{\omega}$ okrojonym do niezbędnego minimum.
Przedstawimy, jak wyglądają termy, typy i wartości tego języka, a także pokażemy, jak przebiega typowanie,
znajdowanie rodzaju, ewaluacja czy sprawdzanie równości typów. Postaramy się pisać jasno i pokażemy parę przykładów, 
aby nieobyty w temacie Czytelnik nie zgubił się.  W rozdziale trzecim do tak zdefiniowanego systemu będziemy wprowadzać
rozszerzenia.

\subsection {Termy i typy w $F_\omega$}

System $F_{\omega}$ to rachunek będący rozszerzeniem $\lambda_{\omega}$ oraz systemu $F$.
Wszystkie trzy wywodzą się z rachunku lambda z typami prostymi. Termy oraz typy definiujemy w $\lambda_{\rightarrow}$ następująco: \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= &  & \textit{termy}  \\
   & $\mathtt{x}$ & \textit{zmienne}  \\
   & $\mathtt{\lambda x:T.t}$ & \textit{abstrakcja} \\
   & $\mathtt{t \hspace{0.2em} t}$ & \textit{aplikacja} \\
   & & \\
  $\mathtt{T}$ ::= &  & \textit{typy} \\
   & $\mathtt{X}$ & \textit{zmienna typowa} \\
   & $\mathtt{T \rightarrow T}$ & \textit{typ funkcji} \\
  \hline
\end{tabular} \\



\subsubsection{System $\lambda_{\omega}$} 

Główną cechą systemu $\lambda_{\omega}$ jest to, że oprócz termów zależnych od termów mamy typy zależne od typów, czyli możemy mówić o aplikacji i abstrakcji typowej, a tak powstałe 'typy' będziemy nazywać konstruktorami. By nam się nie pomyliło z abstrakcją na termach, zmienne konstruktorowe będziemy zaczynać dużą literą. Przykładowo $\mathtt{Tb=\lambda X.X \rightarrow Bool}$ i $\mathtt{\lambda X.X}$ są abstrakcjami konstruktowymi, ale $\mathtt{\lambda x.x}$ jest abstrakcją na termach. 
Do konstruktora $\mathtt{Tb}$ możemy zaaplikować $\mathtt{Bool}$ i dostaniemy $\mathtt{(\lambda X.X \rightarrow Bool)Bool}$ równoważne $\mathtt{Bool \rightarrow Bool}$. Jak widać, użyliśmy słowa \textit{równoważne}. W rachunku lambda z typami prostymi sposób konstrukcji typów gwarantował nam, że dwa typy $\mathtt{T_1}$ i $\mathtt{T_2}$ na pewno są różne (zakładając, że typy bazowe były sobie różne). W $\lambda_{\omega}$ jest inaczej -- konstruktory tego systemu możemy podzielić na klasy równoważności. Do klasy $\mathtt{Bool \rightarrow Bool}$ należą również $\mathtt{ (Tb^n) Bool }$ dla $n$ naturalnego, a $\mathtt{T^n}$ oznacza aplikację $n$ konstruktorów $\mathtt{T}$.
Zauważmy, że odpowiednikiem takiej relacji równoważności w $\lambda_{\rightarrow}$  jest $\beta$-równoważność. W~świecie typów nazwiemy taką relację $\equiv$\footnote{formalnie zdefiniujemy tą relację w rozdziale 2.2.3}. Każdy konstruktor typu jest silnie normalizowalny i zachodzi własność Churcha-Rossera. Przez \texttt{nf(T)} oznaczamy postać normalną konstruktora rodzaju \texttt{T}.
Dodatkowo wprowadzimy następującą regułę:
$\mathtt{\frac{\Gamma \vdash t:S \hspace{1em} S\equiv T  }{\Gamma \vdash t:T}}$
mówiącą, że jeżeli \texttt{S} jest konstruktorem termu \texttt{t}, to dowolny konstruktor \texttt{S} równoważny z \texttt{T} również jest konstruktorem \texttt{t}.  

Niestety, w tak zdefiniowanym systemie powstaje jeden problem. Nie chcielibyśmy, aby $\mathtt{Bool \hspace{0.2em} Bool}$ było dozwolone, tak samo, jak w świecie termów nie chcieliśmy, by $\mathtt{true \hspace{0.2em} true}$ było dozwolone. W świecie termów, by rozwiązać ten problem, wprowadziliśmy typy na termach, w świecie typów wprowadzimy \textit{rodzaje} na konstruktorach. Piszemy, że $\mathtt{T::K}$, czyli konstruktor $\mathtt{T}$ jest rodzaju $\mathtt{K}$. Wprowadzimy też jeden rodzaj bazowy $\mathtt{\ast}$.

Wszystkie typy, jakie pojawiły się w $\lambda_{\rightarrow}$, są rodzaju $\mathtt{\ast}$. Np. $\mathtt{Bool :: \ast}$, $\mathtt{Nat \rightarrow Nat}$, $\mathtt{(Bool \rightarrow Nat) \rightarrow Nat} :: \ast$, itd. Rodzaj $\mathtt{\ast \Rightarrow \ast}$ będzie odpowiadał funkcjom z konstruktorów w konstruktory, np. $\mathtt{\lambda X.X \rightarrow Bool::\ast \Rightarrow \ast }$. $\mathtt{\ast \Rightarrow \ast \Rightarrow \ast}$ bierze konstruktor i zwraca funkcję konstruktorową, np. $\mathtt{\lambda X. \lambda Y. X \rightarrow Y::\ast \Rightarrow \ast \Rightarrow \ast}$, itd. 

Teraz możemy $\lambda_{\rightarrow}$ rozszerzyć o następujące konstrukcje: 
\begin{itemize}
    \item rodzaje \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{K}$ ::= &  & \textit{rodzaje}  \\
   & $\mathtt{\ast}$ & \textit{rodzaj wszystkich typów} \\
   & $\mathtt{K \Rightarrow K}$ & \textit{rodzaj funkcji typowej} \\
  \hline
\end{tabular}
    \item abstrakcję i aplikację typową na typach \\ \\
\begin{tabular}{| l c r |}
   \hline
   $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{\lambda X::K.T}$ & \textit{abstrakcja konstruktorowa} \\
   & $\mathtt{T\;T}$ & \textit{aplikacji konstruktorowa} \\
   \hline
\end{tabular}
\end{itemize} 

Powstaje pytanie, czy wszystkie konstruktory są typami? Otóż nie, typy to konstruktory rodzaju $\mathtt{\ast}$.

\subsubsection{System $F$}

System F jest systemem, w którym dodatkowo, oprócz termów zależnych od termów, mamy termy zależne od typów. Wprowadzimy trzeci już rodzaj abstrakcji i aplikacji, poprzedni był w świecie typów, ten będzie w świecie termów. Znana jest nam funkcja identycznościowa $\mathtt{\lambda x.x}$, w $\lambda_{\rightarrow}$ możemy ją napisać na wiele sposób: $\mathtt{\lambda x:Bool.x}$, $\mathtt{\lambda x:Nat.x}$, $\mathtt{\lambda x:Bool \rightarrow Nat.x}$. W systemie $F$ możemy wszystkie te funkcje zapisać jako: $\mathtt{\lambda X. \lambda x:X.x}$. Zauważmy, że ten \textit{term} przyjmuje jako pierwszy argument typ, następnie term tego typu i zwraca term. Przykładem użycia takiego termu mogą być: $(\mathtt{\lambda X. \lambda x:X.x)\;[Bool]\;true}$, co daje $\mathtt{true}$, albo $(\mathtt{\lambda X. \lambda x:X.x)\;[Nat]\;1}$, co daje $\mathtt{1}$. W ten sposób powstała nam \textit{uniwersalna} funkcja identycznościowa, której nadamy tzw. uniwersalny typ: $\mathtt{\lambda X. \lambda x:X.x \; : \; \forall X.X \rightarrow X}$. Dodatkowo, jako że dodaliśmy już do systemu rodzaje, napiszemy $\mathtt{\lambda X::\ast. \lambda x:X.x \; : \; \forall X::\ast.X \rightarrow X \; ::\ast}$. 

Czy moglibyśmy napisać $\mathtt{\lambda X::\ast \Rightarrow \ast. \lambda x:X.x \; : \; \forall X::\ast \Rightarrow \ast.X \rightarrow X \; ::\ast \Rightarrow \ast}\;$? Jak już mówiliśmy, tylko konstruktory rodzaju $\mathtt{\ast}$ są typami, więc powyższy term nie jest dobry.

Po tym krótkim wstępie możemy już zdefiniować odziedziczone z systemu $F$ własności takie, jak:  
\begin{itemize}
    \item abstrakcję i aplikację typową na termach \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy} \\
   & $\mathtt{\lambda X::K.t}$ & \textit{abstrakcja typowa} \\
   & $\mathtt{t[T]}$ & \textit{aplikacja typowa} \\
  \hline
\end{tabular}

    \item typ uniwersalny \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{\forall X::K.T}$ & \textit{typ uniwersalny} \\
  \hline
\end{tabular}

\end{itemize}


\subsection{Typowanie}

\subsubsection{Kontekst}

\emph{Kontekst typowania} opisany jest następującą składnią abstrakcyjną: \\

\begin{tabular}{ | l c r | }
	\hline
	$\mathtt{\Gamma}$ ::= & & \textit{kontekst}\\
	& $\mathtt{\emptyset}$ & \textit{pusty kontekst} \\
	& $\mathtt{\Gamma,x:T}$& \textit{wiązanie typu} \\ 
	& $\mathtt{\Gamma,X::K}$& \textit{wiązanie rodzaju} \\ 
	\hline
\end{tabular} \\
	
Konteksty typowania bedziemy często traktować jako skończone zbiory wiązań i będziemy
używać teoriomnogościowych symboli na nich. Np. przynależność do kontekstu formalnie
definiujemy jako:
\[
	\frac{}{B \in \Gamma,B}
	\qquad
	\frac{B \in \Gamma}{B \in \Gamma,B'}
\]
Definicje pozostałych operacji teoriomnogościowych są na tyle naturalne, że zostawiamy
je Czytelnikowi do uzupełnienia.


\subsubsection{Podstawienia}
Oprócz zwykłego podstawienia za zmienne, które pozostawiamy Czytelnikowi do uzupełnienia, powinniśmy zdefiniować podstawienie za zmienne konstruktorowe.

    \begin{itemize}
        \item $\mathtt{[Y \mapsto T]X = \begin{cases}  \texttt{T} & Y=X \\ \texttt{X} & \text{w.p.p} \end{cases}}$
        \item $\mathtt{[Y \mapsto T](X_1 \; X_2)  = [Y \mapsto T]X_1 [Y \mapsto T] X_2 }$
        \item $\mathtt{[Y \mapsto T](S_1 \rightarrow S_2) = [Y \mapsto T]S_1 \rightarrow [Y \mapsto T]S_2} $
        \item $\mathtt{[Y \mapsto T]\forall X.S}  = \begin{cases} \mathtt{\forall X.S} & Y=X \text{ lub } Y \notin FV(S) \\ \mathtt{\forall X.[Y \mapsto T]S} & X \notin FV(S)  \text{ i } Y \in FV(S) \end{cases}$
        \item $\mathtt{[Y := T]\lambda X.S }= \begin{cases} \mathtt{\lambda X.S} & Y=X \text{ lub } Y \notin FV(S)\\ \mathtt{\lambda X.[Y \mapsto T]S}  & X \notin FV(S)  \text{ i } Y \in FV(S) \end{cases}$
    \end{itemize}

\subsubsection{Relacja $\equiv$}

Jak wspomnieliśmy w rozdziale 2.1.1, definiujemy na typach relację równoważności. W poniższych wzorach $\mathtt{S,S_1,S_2,T,T_1,T_2}$ to typy, \texttt{K} to rodzaj. Następujące trzy reguły:
	\[\mathtt{
		\frac{}{T \equiv T}
                \qquad
                \frac{S \equiv T}{T \equiv S}}
                \qquad
                \frac{S \equiv U \;\; U \equiv T}{S \equiv T}
	\]
gwarantują nam równoważność relacji $\equiv$. Pozostałe reguły jak następuje:
	\[\mathtt{
		\frac{S_1 \equiv T_1 \;\; S_2 \equiv T_2}{S_1 \rightarrow S_2 \equiv T_1 \rightarrow T_2}
                \qquad
                \frac{S_1 \equiv T_1 \;\; S_2 \equiv T_2}{S_1\;S_2 \equiv T_1\;T_2}}
	\]
	\[\mathtt{
		\frac{S \equiv T}{\lambda X::K.S \equiv \lambda X::K.T}
                \qquad
                (\lambda X::K.S)T \equiv [X \mapsto T]S}
	\] 

definiują równoważność funkcji typowych, aplikacji i abstrakcji konstruktorowych oraz typów uniwersalnych.

\subsubsection{Reguły znajdowania rodzaju}

W systemie $F_\omega$ każdemu poprawnie zbudowanemu typowi przyporządkowujemy rodzaj.
Przyporządkowanie to określa relacja $(.\vdash.::.)$ zdefiniowana następująco.

Jeżeli zachodzi $\mathtt{\Gamma \vdash T :: K}$, to powiemy, że
\emph {typ $\mathtt{T}$ jest rodzaju $\mathtt{K}$ w~kontekście $\mathtt{\Gamma}$}, gdzie
relacja określenia rodzaju $(.\vdash.::.) \subseteq \Gamma \times T \times K$
jest najmniejszą relacją zamkniętą na reguły:
	\[ \mathtt{
		\frac{X::K \in \Gamma}{\Gamma \vdash X::K}
		\qquad
		\frac{\Gamma \vdash T_1 :: K_{1} \Rightarrow K_{2} \hspace{1em} \Gamma \vdash T_2 :: K_{1}}{\Gamma \vdash T_1 T_2 :: K_{2}}}
	\]
	\[ \mathtt{
		\frac{\Gamma \vdash X :: K_1 \hspace{1em} \Gamma \vdash T :: K_2}{\Gamma \vdash \lambda X::K_1. T :: K_{1} \Rightarrow K_{2}}
		\qquad
		\frac{\Gamma \vdash X :: K \hspace{1em} \Gamma \vdash T :: \ast}{\Gamma \vdash \forall X::K. T :: \ast}}
	\]
	\[\mathtt{
		\frac{\Gamma \vdash T_1 : \ast \hspace{1em} \Gamma \vdash T_2 : \ast}{\Gamma \vdash T_1 \rightarrow T_2 : \ast}}
	\]	


\subsubsection{Reguły typowania}

Jesteśmy już gotowi przedstawić reguły typowania zdefiniowanego wyżej systemu $F_\omega$.
Każdemu poprawnie zbudowanemu termowi przyporządkowujemy typ. Przyporządkowanie to określa relacja $(.\vdash.:.)$ zdefiniowana następująco.

	\[\mathtt{
		\frac{x:T \in \Gamma}{\Gamma \vdash x:T}
                \qquad
                \frac{\Gamma \vdash T_1::\ast \hspace{1.5em} \Gamma,x:T_1 \vdash t_2:T_2}{\Gamma \vdash \lambda x:T_1.t_2\;:\;T_1 \rightarrow T_2}}
	\]
	\[\mathtt{
		\frac{\Gamma \vdash t_1:T_1 \rightarrow T_2 \hspace{1.5em} \Gamma \vdash t_2:T_1}{ \Gamma \vdash t_1 \; t_2 : T_2}
                \qquad
                \frac{\Gamma \vdash t:S \hspace{1.5em} S \equiv T \hspace{1.5em} \Gamma \vdash T::\ast}{\Gamma \vdash t:T}}
	\]
	\[\mathtt{
		\frac{\Gamma,X::K \vdash t:T }{\Gamma \vdash \lambda X::K.t \;:\forall X::K.T}
                \qquad
                \frac{\Gamma \vdash t:\forall X::K.T \hspace{1.5em} \Gamma \vdash T'::K}{\Gamma \vdash t[T']\;:[X \mapsto T']T}}
	\]


\subsection{Ewaluacja}

Wartości w $F_\omega$ zdefiniujemy dokładnie jak w $\lambda_{\rightarrow}$. \\ \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{v}$ ::= &  & \textit{wartości}  \\
   & $\mathtt{\lambda x:T.t}$ & \textit{wartość abstrakcji} \\
  \hline
\end{tabular} \\

Ewaluacja przebiega w sposób standardowy dla aplikacji i abstrakcji termów. Teraz, dla czytelności, przetoczymy te reguły ewaluacji ($\mathtt{t_1,t_1',t_2,t_2',t}$ to termy, \texttt{v} to wartość, \texttt{x:T} to zmienna \texttt{x} typu \texttt{T}):
	\[\mathtt{
		\frac{t_1 \longrightarrow t_1'}{t_1\;t_2 \longrightarrow t_1'\;t_2}
                \qquad
                \frac{t_2 \longrightarrow t_2'}{v_1\;t_2 \longrightarrow v_1\;t_2'}}
	\]
 	\[\mathtt{
		(\lambda x:T.t)v \longrightarrow [x \mapsto v]t}
	\]
Do tego dochodzą reguły dla nowych w języku abstrakcji typowych i aplikacji typowych.
	\[\mathtt{
		\frac{t \longrightarrow t'}{t[T] \longrightarrow t'[T]}}
	\]
 	\[\mathtt{
		(\lambda X::K.t)[T] \longrightarrow [X \mapsto T]t}
	\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rozszerzenia $F_\omega$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}

W rozdziale tym chcielibyśmy poruszyć, jak w systemie $F_\omega$ zdefiniować najprostrze
konstrukcje, takie jak wyrażenia arytmetyczne i logiczne, warianty, sekwencje wyrażeń, 
typy egzystencjalne, rekordy i inne. Pokażemy również, jak przebiega typowanie, ewaluacja i 
gdzieniegdzie dodamy reguły tworzenia rodzaju.

Chcielibysmy podkreślić, że następująca reguła typowania:

 	\[\mathtt{ \frac{\Gamma \vdash t:T \;\;\; S\equiv T \;\;\; \Gamma \vdash S::\ast}{\Gamma \vdash t:S}
		}
	\]
bardzo ułatwia definiowanie reguł typowania w $F_\omega$. W większości przypadków są one takie same lub
lekko zmodyfikowane, dlatego nie powinny nastręczać trudności.

\subsection{wyrażenia arytmetyczne i logiczne}

Wyreżania arytmetyczne i logiczne to część, bez której żaden język się nie obędzie. Oczywiście można je sobie zakodować w systemie $F_\omega$, ale normą są wbudowane w język wyrażenia. Termy, typy i wartości wyrażeń zdefiniujemy następująco: \\

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{true}$ & \textit{prawda}  \\
   & $\mathtt{false}$ & \textit{fałsz} \\
   & $\mathtt{zero}$ & \textit{zero} \\
   & $\mathtt{succ\;t}$ & \textit{następnik}  \\
   & $\mathtt{pred\;t}$ & \textit{poprzednik} \\
   & $\mathtt{iszero}$ & \textit{test na zero} \\
   & $\mathtt{if\;t\;then\;t\;else\;t}$ & \textit{warunek} \\
   & & \\
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy} \\
   & $\mathtt{Nat}$ & \textit{typ liczbowy} \\
   & $\mathtt{Bool}$ & \textit{typ boolowski} \\
   & & \\
  $\mathtt{v}$ ::= & $\dots$ & \textit{typy} \\
   & $\mathtt{true}$ & \textit{wartość prawdy} \\
   & $\mathtt{false}$ & \textit{wartość fałszu} \\
   & $\mathtt{nv}$ & \textit{wartość liczbowa} \\
   & & \\
  $\mathtt{nv}$ ::= & $\dots$ & \textit{wartość liczbowa} \\
   & $\mathtt{zero}$ & \textit{wartość zera} \\
   & $\mathtt{succ\;nv}$ & \textit{wartość następnika} \\
  \hline
\end{tabular} \\

Na pewno musimy dodać reguły tworzenia rodzaju dla \texttt{Nat} i \texttt{Bool}, którym nadamy rodzaj~$\mathtt{\ast}$:
 	\[\mathtt{ \frac{}{\Gamma \vdash Bool::\ast} \qquad \frac{}{\Gamma \vdash Nat::\ast}
		}
	\]

Typowanie wygląda dokładnie tak samo jak w rachunku lambda z typami prostymi. Możemy sobie pozwolić na takie reguły dzięki regule XXX.
Przykładowo, nie tylko termy typu \texttt{Nat} mogą się dobrze otypować, gdy zaaplikujemy je do \texttt{succ}. Dla $\mathtt{t:(\lambda X.X)Nat}$
otrzymamy:

 	\[\mathtt{ \frac{\frac{\Gamma \vdash t:(\lambda X.X)Nat\hspace{2em}\Gamma \vdash (\lambda X.X)Nat \equiv Nat \hspace{2em}\Gamma \vdash (\lambda X.X)Nat::\ast}{\Gamma \vdash t:Nat}}{\Gamma \vdash succ\;t:Nat} 
		}
	\]
Nie musimy również pisać reguł typu:~\[\mathtt{\frac{\Gamma \vdash t_1:Bool \;\;\; \Gamma \vdash t_2:T \;\;\; \Gamma \vdash t_3:T\;\;\; \Gamma \vdash T::\ast}{\Gamma \vdash if\;t_1\;then\;t_2\;else\;t_3:T} 
		}
	\]
ponieważ posiadanie typu przez term $\mathtt{t_2}$ gwarantuje nam, że ten typ będzie rodzaju $\mathtt{\ast}$.
Stąd, reguły typowania wyrażeń arytmetycznych i logicznych wyglądają następująco w $F_\omega$:~\[\mathtt{ \frac{}{\Gamma \vdash true:Bool} \qquad \frac{}{\Gamma \vdash false:Bool} \quad \frac{\Gamma \vdash t:Nat}{\Gamma \vdash iszero\;t:Bool}
		}
	\]
 	\[\mathtt{\frac{\Gamma \vdash t_1:Bool \;\;\; \Gamma \vdash t_2:T \;\;\; \Gamma \vdash t_3:T}{\Gamma \vdash if\;t_1\;then\;t_2\;else\;t_3:T} 
		}
	\]
 	\[\mathtt{ \frac{}{\Gamma \vdash zero:Nat} \qquad \frac{\Gamma \vdash t:Nat}{\Gamma \vdash succ\;t:Nat} \qquad \frac{\Gamma \vdash t:Nat}{\Gamma \vdash pred\;t:Nat} 
		}
	\]
Zdefiniowanie reguł ewaluacji pozostawiamy Czytelnikowi.

\subsection{Unit i sekwencje}

W rachunku lambda z typami prostymi dodaliśmy do składnię języka rozszerzaliśmy o konstrukcje takie, jak: 

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{unit}$ & \textit{term unit} \\
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{Unit}$ & \textit{typ unit} \\
  $\mathtt{v}$ ::= & $\dots$ & \textit{wartości}  \\
   & $\mathtt{unit}$ & \textit{wartość unit} \\
  \hline
\end{tabular} \\

natomiast typowanie przebiegało następująco:~\[\mathtt{ \frac{}{\Gamma \vdash unit:Unit}
		}
	\]
a sekwencje definiowaliśmy jako:~\[\mathtt{ t_1;t_2 \;\overset{def}{=}\; (\lambda x:Unit.t_2)t_1 \hspace{3em} \text{gdzie x $\notin$ FV($t_2$)}
		}
	\]
Aby pozostać przy wbudowanym unit w język wystarczy dodać regułę znajdowania rodzaju dla typu \texttt{Unit}:~\[\mathtt{ \frac{}{\Gamma \vdash Unit::\ast}
		}
	\]

W rachunku $F_\omega$ pojawia się możliwość zakodowania \texttt{unit} i \texttt{Unit}. Robimy to w taki sposób:
$\mathtt{unit \;\overset{def}{=}\;= \lambda X::\ast.\lambda x:X.x}$ \\
$\mathtt{Unit \;\overset{def}{=}\; \forall X::\ast.X \rightarrow X}$ \\


\subsection{Anotacje typowe}

Anotacje typowe są przydatną konstrukcją używaną na przykład przy typach egzystencjalnych.\\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\cdots$ & \textit{termy}  \\
   & $\mathtt{t\;as\;T}$ &\textit{anotacja typowa} \\
  \hline
\end{tabular} \\

Ewaluacja i typowanie nie zmieniają się.

\subsection{Definicje lokalne}

 	\[\mathtt{let\;x=t_1\;in\;t_2 \;\overset{def}{=}\;(\lambda x:T.t_2)t_1 \hspace{3em}\text{gdzie}\; t_1:T 
		}
	\]

\subsection{Rekordy}

Składnię rekorów zdefiniujemy następująco:\\

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{\{l_i=t_i^{\;\;\;i \in 1..n}\}}$ & \textit{rekord} \\
   & $\mathtt{t.l}$ & \textit{projekcja} \\ 
   & & \\
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{\{l_i:T_i^{\;\;\;i \in 1..n}\}}$ & \textit{typ rekordu} \\
   & & \\
  $\mathtt{v}$ ::= & $\dots$ & \textit{wartości}  \\
   & $\mathtt{\{l_i=v_i^{\;\;\;i \in 1..n}\}}$ & \textit{wartość rekordu} \\
  \hline
\end{tabular} \\

Do relacji tworzenia rodzaju dodamy regułę nadającą rodzaj typowi $\mathtt{\{l_i:T_i^{\;\;\;i \in 1..n}\}}$:~\[\mathtt{
             \frac{\Gamma \vdash T_1::\ast \;\dots\;\Gamma \vdash T_n::\ast}{\Gamma \vdash \{l_i:T_i^{\;\;\;i \in 1..n}\}::\ast}
		}
	\]
oraz wprowadzimy niewielkie zmiany w regułach typowania:~\[\mathtt{
             \frac{\Gamma \vdash t_1:T_1 \;\dots\;\Gamma \vdash t_n:T_n \hspace{2em} \Gamma \vdash \{l_i:T_i^{\;\;\;i \in 1..n}\}::\ast}{\Gamma \vdash \{l_i=t_i^{\;\;\;i \in 1..n}\}:\{l_i:T_i^{\;\;\;i \in 1..n}\}}
            }
	\]
 	\[\mathtt{
           \frac{\Gamma \vdash t : \{l_i:T_i^{\;\;\;i \in 1..n}\}}{\Gamma \vdash t.i : T_i} 
            }
	\]
a ewaluację pozostawimy bez zmian: \\
 	\[\mathtt{
                \{l_i=v_i^{\;\;\;i \in 1..n}\}.i \longrightarrow v_i
                \qquad
                \frac{e \longrightarrow e'}{e.i \longrightarrow e'.i}
		}
	\]
\small{
 	\[\mathtt{
                \frac{t_i \longrightarrow t_i'}{\{l_1=v_1, \dots, l_{i-1}=v_{i-1}, l_i=t_i, \dots, l_n=t_n\} \longrightarrow \{l_1=v_1, \dots, l_{i-1}=v_{i-1}, l_i=t_i', \dots, l_n=t_n\}}
		}
	\]
}
\subsection{Warianty}

Składnię wariantów zdefiniujemy następująco:\\

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{<l=t>\;as\;T}$ & \textit{tagowanie} \\
   & $\mathtt{case\;t\;of\;<l_i=x_i>\Rightarrow t_i^{\;\;\;i \in 1..n}}$ & \textit{case}\\
   & & \\
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{<l_i:T_i^{\;\;\;i \in 1..n}>}$ & \textit{typ wariantu}\\
  \hline
\end{tabular} \\

Podobnie jak przy rekordach, typ wariantu dostanie rodzaj $\mathtt{\ast}$:
 	\[\mathtt{
             \frac{\Gamma \vdash T_1::\ast \;\dots\;\Gamma \vdash T_n::\ast}{\Gamma \vdash <l_i:T_i^{\;\;\;i \in 1..n}>::\ast}
		}
	\]
a w regułąch typowania wprowadzimy małe zmiany:
 	\[\mathtt{ \frac{\Gamma \vdash t_0:<l_i:T_i^{\;\;\;i \in 1..n}> \hspace{2em} \Gamma,x_1:T_1 \vdash t_1:T \;\dots\; \Gamma,x_n:T_n \vdash t_n:T}{\Gamma \vdash case\;t_0\;of\;<l_i=x_i>\Rightarrow t_i^{\;\;\;i \in 1..n}\; : T}
		}
	\]
 	\[\mathtt{ \frac{\Gamma \vdash t_j : T_j \hspace{2em} \Gamma \vdash <l_i:T_i^{\;\;\;i \in 1..n}>::\ast}{\Gamma \vdash <l_j=t_j> as <l_i:T_i^{\;\;\;i \in 1..n}> \;: <l_i:\;T_i^{\;\;\;i \in 1..n}>}
		}
	\]
natomiast ewaluacja pozostanie bez zmian:
 	\[\mathtt{ case\;(<l_j=t_j>\;as\;T)\;of\;<l_i=x_i>\Rightarrow t_i^{\;\;\;i \in 1..n} \longrightarrow [x_j \mapsto v_j]t_j
		}
	\]
 	\[\mathtt{ \frac{t \longrightarrow t'}{case\;t\;of\;<l_i=x_i>\Rightarrow t_i^{\;\;\;i \in 1..n} \longrightarrow case\;t'\;of\;<l_i=x_i>\Rightarrow t_i^{\;\;\;i \in 1..n} }
		}
	\]
 	\[\mathtt{ \frac{t_j \longrightarrow t_j'}{<l_j=t_j>\;as\;T \longrightarrow <l_j=t_j'>\;as\;T }
		}
	\]

\subsection{Punkt stały}

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{fix \;t.v}$ & \textit{punkt stały}\\
  \hline
\end{tabular} \\

Typowanie \\
 	\[\mathtt{\frac{\Gamma, f:T \vdash v:S \hspace{2em} \Gamma \vdash T::\ast\hspace{2em} \Gamma \vdash S::\ast \hspace{2em} S\equiv T}{\Gamma \vdash fix\;f.v:T}}
	\]
Ewaluacja \\
 	\[\mathtt{ fix\;f.v \longrightarrow [f \mapsto fix\;f.v]v
		}
	\]

\subsection{Listy}

Jako przykład wbudowanych typów danych wybraliśmy listy. Podobne rekursywne struktury, jak na przykład drzewa, możemy dodać do języka w analogiczny sposób, jednak rekurencyjne typy danych odwiodą nas od tej konieczności. \\
  
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{nil[T]}$ & \textit{lista pusta}  \\
   & $\mathtt{cons[T]\;t\;t}$ & \textit{konstruktor listy} \\
   & $\mathtt{isnil[T]\;t}$ & \textit{test na pustość listy} \\
   & $\mathtt{head[T]\;t\;t}$ & \textit{głowa listy} \\
   & $\mathtt{tail[T]\;t}$ & \textit{ogon listy} \\
   & & \\
  $\mathtt{T}$ ::= &  & \textit{typy} \\
   & $\mathtt{List\;T}$ & \textit{typ listy} \\
   & & \\
  $\mathtt{v}$ ::= &  & \textit{typy} \\
   & $\mathtt{nil\;[T]}$ & \textit{wartość pustej listy} \\
   & $\mathtt{cons\;[T]\;v\;v}$ & \textit{wartość listy niepustej} \\
  \hline
\end{tabular} \\

Tworzenie rodzaju:
 	\[\mathtt{ \frac{\Gamma \vdash T::\ast}{\Gamma \vdash List\;T::\ast}
		}
	\]
Typowanie:
 	\[\mathtt{ \frac{\Gamma \vdash List\;T :: \ast}{\Gamma \vdash nil[T] : List\;T } \qquad \frac{\Gamma \vdash t_1:T \;\;\;\Gamma \vdash t_2:List\;T}{\Gamma \vdash List[T]\;t_1\;t_2:List\;T}
		}
	\]
 	\[\mathtt{ \frac{\Gamma \vdash t:List\;T }{\Gamma \vdash head[T]\;t : T } \qquad \frac{\Gamma \vdash t:List\;T }{\Gamma \vdash tail[T]\;t : List\;T }
		}
	\]
Ewaluacja:
 	\[\mathtt{ aaa
		}
	\]
\subsection{Typy egzystencjalne}

System $F_\omega$ jest już w stanie zakodować typy egzystencjalne, choć wbudowane typy egzystencjalne niczemu nie szkodzą. Pokażemy oba podejścia do tego problemu, zaczynając od przedstawienia składni: \\

\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\cdots$ & \textit{termy}  \\
   & $\mathtt{\{^*T::K,t\}\;as\;T}$ & \textit{pakowanie} \\
   & $\mathtt{let\;\{X,x\}=t\;in\;t}$ & \textit{odpakowanie} \\
   & & \\
  $\mathtt{T}$ ::= & $\cdots$ & \textit{typy}  \\
   & $\mathtt{\{\exists X::K,T\}}$ & \textit{typ egzystencjalny} \\
   & & \\
  $\mathtt{v}$ ::= & $\cdots$ & \textit{wartości}  \\
   & $\mathtt{\{^*T,v\}\;as\;T}$ & \textit{pakowanie} \\
  \hline
\end{tabular} \\

W systemie $F_\omega$ powyższe elementy języka możemy zdefiniować następująco: \\
$\mathtt{\{\exists X::K,T\}\;\overset{def}{=}\;\forall Y::\ast.(\forall X::K.T \rightarrow Y) \rightarrow Y}$ \\
$\mathtt{\{^*U::K,t\}\;as\; \{\exists X::K,T\}\; \overset{def}{=} \;let\;x=t\;in\;\lambda Y::\ast.(\lambda f:\forall X::K.T \rightarrow Y) .f\;[U]\;x}$ \\
$\mathtt{let\;\{X::K,x\}=t\;in\;t'\;\overset{def}{=}\;t[T'](\lambda X::K.\lambda x:T.t')\hspace{3em} \text{gdzie $\mathtt{t':T'}$} }$ \\ \\

Zauważmy, że dopiero obecność rodzajów pozwoliła nam na tego rodzaju sztuczki. W~systemie $F$ nie umiemy tak zrobić.

Na pierwszy rzut oka termy te są niezrozumiałe. Ależ jak bardzo można się mylić -- są miłe i przyjemne dla swych wielbicieli. Pokażemy, że zachodzą podstawowe własności pakowania i odpakowania. \\
Rozważmy term $\mathtt{ \{^*U::K,t\}\;as\; \{\exists X::K,T\}}$. \\ 
$ \mathtt{ \{^*U::K,t\}\;as\; \{\exists X::K,T\} }$ \\ 
$ \mathtt{ = let\;x=t\;in\;\lambda Y::\ast.\lambda f:(\forall X::K.T \rightarrow Y).f[U]x = }$ \\
$ \mathtt{ = (\lambda x:[X \mapsto U]T.\lambda Y::\ast.\lambda f:(\forall X::K.T \rightarrow Y).f[U]x)t = }$ \\
$ \mathtt{ \overset{t:[X \mapsto U]T}{=} \lambda Y::\ast.\lambda f:(\forall X::K.T \rightarrow Y).f[U](t:[X \mapsto U]T)}$ \\
co jest typu $\mathtt{\forall Y::\ast.(\forall X::K.T \rightarrow Y) \rightarrow Y}$, czyli z definicji $\mathtt{\{\exists X::K,T\}}$. \\

Rozważmy bardziej życiowy przykład, aby Czytelnik mógł jeszcze raz przeanalizować pakowanie. Oto typowanie w systemie $F$ przykładowego termu:\\ 
 	\[\mathtt{ \frac{\Gamma \vdash \{a=zero, f:\lambda x:Nat.succ\;x\}:[X \mapsto Nat]\{a:X,f:X \rightarrow Nat\}}{\Gamma \{^*X,\{a=zero, f:\lambda x:Nat.succ\;x\}\}\;as\;\{\exists X,\{a:X,f:X \rightarrow Nat\}\}}
		}
	\]
Następnie wyprowadzimy ten term w $F_\omega$: \\ \\
\small{
$ \mathtt{ \{Nat::K,\{a=zero, f:\lambda x:Nat.succ\;x\}\}\;as\; \{\exists X::K,\{a:X, f:X \rightarrow Nat\}\}= }$ \\ 
$ \mathtt{ = let\;x=\{a=zero, f:\lambda x:Nat.succ\;x\}\;in\;\lambda Y::\ast.\lambda f:(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y).f[Nat]x = }$ \\
$ \mathtt{ = (\lambda x:[X \mapsto Nat]\{a:X, f:X \rightarrow Nat\}.\lambda Y::\ast.\lambda f:(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y).f[Nat]x)}$\\
$ \mathtt{ \{a=zero, f:\lambda x:Nat.succ\;x\} \overset{\{a=zero, f:\lambda x:Nat.succ\;x\}:[X \mapsto Nat]\{a:X, f:X \rightarrow Nat\}}{=}  }$ \\
$ \mathtt{ = \lambda Y::\ast.\lambda f:(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y).f[Nat]\{a=zero, f:\lambda x:Nat.succ\;x\}}$ \\ \\
co jest typu $\mathtt{\forall Y::\ast.(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y) \rightarrow Y}$, czyli z definicji $\mathtt{\{\exists X::K,\{a:X, f:X \rightarrow Nat\}\}}$. \\
}

\normalsize{Uważne odpakowanie otrzymanego termu pozostawiamy Czytelnikowi jako ćwiczenie, my pozwolimy sobie przeprowadzać schemat wywodu:}\\
\scriptsize{
$ \mathtt{let\;\{X,x\}=\lambda Y::\ast.\lambda f:(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y).f[Nat]\{a=zero, f:\lambda x:Nat.succ\;x\}\;in\;(x.f\;x.a)=}$ \\
$ \mathtt{=(\lambda Y::\ast.\lambda f:(\forall X::K.\{a:X, f:X \rightarrow Nat\} \rightarrow Y).f[Nat]\{a=zero, f:\lambda x:Nat.succ\;x\})[T'](\lambda X::K.\lambda x:T.(x.f\;x.a))=}$\\
}
$ \mathtt{=((\lambda X::K.\lambda x:T.(x.f\;x.a))[Nat](\{a=zero, f:\lambda x:Nat.succ\;x\}:[X \mapsto Nat]\{a:X, f:X \rightarrow Nat\}))=}$ \\
$ \mathtt{=(\{a=zero, f:\lambda x:Nat.succ\;x\}.f\;\{a=zero, f:\lambda x:Nat.succ\;x\}.a)=}$ \\
$ \mathtt{=(\lambda x:Nat.succ\;x)zero=succ\;zero}$ \\ 


\normalsize{
Przykłady powyższe obrazują działanie zakodowanych typów rekurencyjnych. Teraz zdefiniujemy wbudowane w język konstrukcje typów rekurencyjnych dla systemu $F_\omega$. Do definicji termów, typów i wartości dodaliśmy już elementy w tabelce na początku rozdziału. Pokażemy, w jaki sposób przebiega typowanie i ewaluacja. \\
}


Tworzenie rodzaju:
 	\[\mathtt{ \frac{a\;tutaj\;co?}{\Gamma \vdash \{\exists X::K,T\}::K}
		}
	\]
Typowanie:
 	\[\mathtt{ \frac{\Gamma \vdash t:[X \mapsto U]T\hspace{2em}\Gamma \vdash U::K \hspace{2em}\Gamma \vdash \{\exists X::K,T\}::\ast}{\Gamma \vdash \{^*U::K,t\}\;as\;\{\exists X::K,T\} \; : \; \{\exists X::K,T\}}
		}
	\]
 	\[\mathtt{ \frac{\Gamma \vdash t_1:\{\exists X::K,T_1\}\hspace{2em}\Gamma,X::K,x:T_1 \vdash t_2:T_2}{\Gamma \vdash let\;\{X,x\}=t_1\;in\;t_2:T_2}
		}
	\]
Ewaluacja:
 	\[\mathtt{ let\;\{X,x\}=(\{^*U::K,v\}\;as\;T)\;\;in\;t \longrightarrow [X \mapsto U][x \mapsto v]t
		}
	\]
 	\[\mathtt{ \frac{t \longrightarrow t'}{\{^*U::K,t\}\;as\;T \longrightarrow \{^*U::K,t'\}\;as\;T}
		}
	\]
 	\[\mathtt{ \frac{t_1\longrightarrow t_1'}{let\;\{X,x\}=t_1\;\;in\;t_2 \longrightarrow let\;\{X,x\}=t_1'\;\;in\;t_2}
		}
	\]
\subsection{Typy rekurencyjne}

Hmmm, no tu musze się zastanowić, to na dole dla zwykłej wersji. \\
\begin{tabular}{| l c r |}
  \hline
  $\mathtt{t}$ ::= & $\dots$ & \textit{termy}  \\
   & $\mathtt{fold[T]\;t}$ & \textit{folding} \\
   & $\mathtt{unfold[T]\;t}$ & \textit{unfolding}\\
   & & \\
  $\mathtt{T}$ ::= & $\dots$ & \textit{typy}  \\
   & $\mathtt{\mu X.T}$ & \textit{typ rekursywny} \\
   & & \\
  $\mathtt{v}$ ::= & $\dots$ & \textit{wartości}  \\
   & $\mathtt{fold[T]\;v}$ & \textit{folding} \\
  \hline  
\end{tabular} \\
Tworzenie rodzaju:
 	\[\mathtt{\frac{}{\Gamma \vdash \mu X.T::\ast}
		}
	\]
Typowanie:
 	\[\mathtt{ \frac{ U=\mu X.T \hspace{2em} \Gamma \vdash t:[X\mapsto U]U}{\Gamma \vdash fold[U]\;t\; : U}
		}
	\]
Ewaluacja:
 	\[\mathtt{
		}
	\]

\subsection{dopasowanie wzorca}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sładnia abstrakcyjna języka}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semantyka i typowanie}                                 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rekonstrukcja typów}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Własności i dowody}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}

\subsection{Inne własności $F_\omega$}

\begin{definicja}
Reguły przepisywania typów w systemie $F_{\omega}$ w wersji Curry'ego standardowe, oprócz: \\

$\frac{\Gamma \vdash M : \forall X \sigma}{\Gamma \vdash M : nf(\sigma [ X := \tau ])}$

\end{definicja}


Nierozstzygalne są problemy:
    \begin{itemize}
        \item sprawdzania typu: dane $\Gamma, M, \tau$, Czy $\Gamma \vdash M : \tau$
        \item typowalność: dane M, Czy $\exists \Gamma \tau . \Gamma \vdash M : \tau$
    \end{itemize}


\subsection{pare słów o rozszerzeniach}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Praktyczne zastosowanie}                       
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Podsumowanie}                       
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{equation}{0}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliografia
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\thispagestyle{empty}
\begin{thebibliography}{99}

\bibitem{ChK} Pierce, \textit{} 


	  
\end{thebibliography}

\end{document}

